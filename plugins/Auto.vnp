#struct provided in https://www.assettocorsa.net/forum/index.php?threads/acc-shared-memory-documentation.59965/
from dataclasses import dataclass
from ctypes import Structure, sizeof, c_double, c_float, c_int32, c_byte, c_int, c_wchar, c_int16, c_uint16, c_int8, c_uint8, c_char
import ctypes
import time
import mmap
import math
import struct
from enum import Enum
from array import array
from multiprocessing import shared_memory
import re
import argparse
import yaml
from threading import Thread
from urllib import request, error
from yaml.reader import Reader as YamlReader
import json
import os
from utils import *
try:
    from yaml.cyaml import CSafeLoader as YamlSafeLoader
except ImportError:
    from yaml import SafeLoader as YamlSafeLoader

class Uint8Descriptor(object):
    def __init__(self, number=None):
        self.number = number

    def __get__(self, obj, objtype):
        return self.number

    def __set__(self, obj, number):
        if number > 255:
            self.number = 255
        elif number < 0:
            self.number = 0
        else:
            self.number = number

class Int8Descriptor(object):
    def __init__(self, number=None):
        self.number = number

    def __get__(self, obj, objtype):
        return self.number

    def __set__(self, obj, number):
        if number > 127:
            self.number = 127
        elif number <= -128:
            self.number = -128
        else:
            self.number = number

class Uint16Descriptor(object):
    def __init__(self, number=None):
        self.number = number

    def __get__(self, obj, objtype):
        return self.number

    def __set__(self, obj, number):
        if number > 65535:
            self.number = 65535
        elif number <= 0:
            self.number = 0
        else:
            self.number = number

class Int16Descriptor(object):
    def __init__(self, number=None):
        self.number = number

    def __get__(self, obj, objtype):
        return self.number

    def __set__(self, obj, number):
        if number > 32767:
            self.number = 32767
        elif number <= -32768:
            self.number = -32768
        else:
            self.number = number

class Descriptor(object):
    def __init__(self, number=None):
        self.number = number
    def __get__(self, obj, objtype):
        return self.number
    def __set__(self, obj, number):
        self.number = number

@dataclass
class TelemetryFFBReport:
    reportID = Uint8Descriptor()
    telemetryReportId = Uint8Descriptor()
    vnmSteeringAngle = Int16Descriptor()
    vnmMaxSteeringAngle = Uint16Descriptor()
    vnmFinalFFB = Int16Descriptor()
    vnmThrottle = Uint16Descriptor()
    vnmBrake = Uint16Descriptor()
    vnmClutch = Uint16Descriptor()
    vnmGear = Int8Descriptor()
    vnmRpm = Uint16Descriptor()
    vnmRpmMax = Uint16Descriptor()
    vnmSpeedKmh = Uint16Descriptor()
    vnmBrakeBias = Uint16Descriptor()
    vnmTC = Uint8Descriptor()
    vnmTCCut = Uint8Descriptor()
    vnmABS = Uint8Descriptor()
    VnmTCinAction = Uint8Descriptor()
    VnmABSinAction = Uint8Descriptor()
    VnmEngineMap = Uint8Descriptor()
    vnmTurboBoost = Uint8Descriptor()
    vnmPitLimiterOn = Uint8Descriptor()
    vnmIgnitionOn = Uint8Descriptor()
    vnmStarterEngineOn = Uint8Descriptor()
    vnmIsEngineRunning = Uint8Descriptor()
    vnmKerbVibration = Int16Descriptor()
    vnmSlipVibrations = Int16Descriptor()
    vnmGVibrations = Int16Descriptor()
    vnmAbsVibrations = Int16Descriptor()
    vnmFuel = Uint16Descriptor()
    vnmFuelMax = Uint16Descriptor()
    vnmFuelXLap = Uint16Descriptor()
    vnmFuelEstimatedLaps = Uint16Descriptor()
    def __init__(self, reportID: c_byte, telemetryReportId: c_byte, vnmSteeringAngle: c_int16, vnmMaxSteeringAngle: c_uint16, vnmFinalFFB: c_int16, vnmThrottle: c_uint16, vnmBrake: c_uint16, vnmClutch: c_uint16, vnmGear: c_uint8, vnmRpm: c_uint16, vnmRpmMax: c_uint16, vnmSpeedKmh: c_uint16, vnmBrakeBias: c_uint16, vnmTC: c_uint8, vnmTCCut: c_uint8, vnmABS: c_uint8, VnmTCinAction: c_uint8, VnmABSinAction: c_uint8, VnmEngineMap: c_uint8, vnmTurboBoost: c_uint8, vnmPitLimiterOn: c_uint8, vnmIgnitionOn: c_uint8, vnmStarterEngineOn: c_uint8, vnmIsEngineRunning: c_uint8, vnmKerbVibration: c_int16, vnmSlipVibrations: c_int16, vnmGVibrations: c_int16, vnmAbsVibrations: c_int16, vnmFuel: c_uint16, vnmFuelMax: c_uint16, vnmFuelXLap: c_uint16, vnmFuelEstimatedLaps: c_uint16):
        self.reportID = reportID
        self.telemetryReportId = telemetryReportId
        self.vnmSteeringAngle = vnmSteeringAngle
        self.vnmMaxSteeringAngle = vnmMaxSteeringAngle
        self.vnmFinalFFB = vnmFinalFFB
        self.vnmThrottle = vnmThrottle
        self.vnmBrake = vnmBrake
        self.vnmClutch = vnmClutch
        self.vnmGear = vnmGear
        self.vnmRpm = vnmRpm
        self.vnmRpmMax = vnmRpmMax
        self.vnmSpeedKmh = vnmSpeedKmh
        self.vnmBrakeBias = vnmBrakeBias
        self.vnmTC = vnmTC
        self.vnmTCCut = vnmTCCut
        self.vnmABS = vnmABS
        self.VnmTCinAction = VnmTCinAction
        self.VnmABSinAction = VnmABSinAction
        self.VnmEngineMap = VnmEngineMap
        self.vnmTurboBoost = vnmTurboBoost
        self.vnmPitLimiterOn = vnmPitLimiterOn
        self.vnmIgnitionOn = vnmIgnitionOn
        self.vnmStarterEngineOn = vnmStarterEngineOn
        self.vnmIsEngineRunning = vnmIsEngineRunning
        self.vnmKerbVibration = vnmKerbVibration
        self.vnmSlipVibrations = vnmSlipVibrations
        self.vnmGVibrations = vnmGVibrations
        self.vnmAbsVibrations = vnmAbsVibrations
        self.vnmFuel = vnmFuel
        self.vnmFuelMax = vnmFuelMax
        self.vnmFuelXLap = vnmFuelXLap
        self.vnmFuelEstimatedLaps = vnmFuelEstimatedLaps
    def to_bytes(self):
        # Define the format specifiers for struct.pack
        format_string = '<BBhHhHHHbHHHHBBBBBBBBBBBhhhhHHHH'  # Assuming two integer values in this example
        # Pack the values into a bytearray
        packed_data = struct.pack(format_string, self.reportID, self.telemetryReportId, self.vnmSteeringAngle, self.vnmMaxSteeringAngle, self.vnmFinalFFB, self.vnmThrottle, self.vnmBrake, self.vnmClutch, self.vnmGear, self.vnmRpm, self.vnmRpmMax, self.vnmSpeedKmh, self.vnmBrakeBias, self.vnmTC, self.vnmTCCut, self.vnmABS, self.VnmTCinAction, self.VnmABSinAction, self.VnmEngineMap, self.vnmTurboBoost, self.vnmPitLimiterOn, self.vnmIgnitionOn, self.vnmStarterEngineOn, self.vnmIsEngineRunning, self.vnmKerbVibration, self.vnmSlipVibrations, self.vnmGVibrations, self.vnmAbsVibrations, self.vnmFuel, self.vnmFuelMax, self.vnmFuelXLap, self.vnmFuelEstimatedLaps)
        return bytearray(packed_data)

class RunningGame(Enum):
    NONE = 0
    AC_ACC = 1
    IRACING = 2
    RF2_LMU = 3
    RR = 4

vnm_data_format_string = '<IIIIfff'

@dataclass
class VnmDataReport:
    acAccUpdatedAt = Descriptor()
    iracingUpdatedAt = Descriptor()
    rf2LmuUpdatedAt = Descriptor()
    r3eUpdatedAt = Descriptor()
    suspensionLeft = Descriptor()
    suspensionRight = Descriptor()
    rf2LmuOldroadTexture = Descriptor()

    def __init__(self, acAccUpdatedAt: c_int, iracingUpdatedAt: c_int, rf2LmuUpdatedAt: c_int, r3eUpdatedAt: c_int, suspensionLeft: c_float, suspensionRight: c_float, rf2LmuOldroadTexture: c_float):
        self.acAccUpdatedAt = acAccUpdatedAt
        self.iracingUpdatedAt = iracingUpdatedAt
        self.rf2LmuUpdatedAt = rf2LmuUpdatedAt
        self.r3eUpdatedAt = r3eUpdatedAt
        self.suspensionLeft = suspensionLeft
        self.suspensionRight = suspensionRight
        self.rf2LmuOldroadTexture = rf2LmuOldroadTexture

    def to_bytes(self):
        # Define the format specifiers for struct.pack
        packed_data = struct.pack(vnm_data_format_string, self.acAccUpdatedAt, self.iracingUpdatedAt, self.rf2LmuUpdatedAt, self.r3eUpdatedAt, self.suspensionLeft, self.suspensionRight, self.rf2LmuOldroadTexture)
        return bytearray(packed_data)

def converByteArrayToVnmDataReport(arr):
    vnmData = VnmDataReport(arr[0],arr[1],arr[2], arr[3],arr[4],arr[5],arr[6])
    return vnmData

def clamp(value, min_value, max_value):
    return max(min_value, min(value, max_value))

def map_value(value, from_min, from_max, to_min, to_max):
    # Calculate the proportion of the value within the original range
    proportion = (value - from_min) / (from_max - from_min)
    # Map the proportion to the new range
    mapped_value = to_min + (proportion * (to_max - to_min))
    return mapped_value

if Datas.Value["ProfileChanged"] == "1":
    pluginConfig = json.loads(Datas.Value["ActiveProfile"])
else:
    pluginConfig = {}
    pluginConfig["ForceReductionThresholdDeg"] = 0
    pluginConfig["ForceReductionFactor"] = 0
    pluginConfig["RoadTextureGain"] = 0


def check_plugin_config_change():
    global pluginConfig
    if Datas.Value["ProfileChanged"] == "1":
        pluginConfig = json.loads(Datas.Value["ActiveProfile"])
        Datas.Value["ProfileChanged"] = "0"
        #with open('plugins/pluginConfig.json', "w") as f:
            #json.dump(pluginConfig, f, indent=4)


ffbReport = TelemetryFFBReport(26, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
Datas.Value["VNM_DATA_REPORT"] = VnmDataReport(0,0,0,0,0.1,0,0).to_bytes()
connectedGame = RunningGame.NONE

def map_value(value, from_min, from_max, to_min, to_max):
    # Calculate the proportion of the value within the original range
    if (from_max == from_min):
        return value
    else:
        proportion = (value - from_min) / (from_max - from_min)
        # Map the proportion to the new range
        mapped_value = to_min + (proportion * (to_max - to_min))
        return mapped_value
############################################################################   AC/ACC     ##############################################################################################################
#struct provided in https://www.assettocorsa.net/forum/index.php?threads/acc-shared-memory-documentation.59965/

class Car():
    def __init__(self, carModel, brakeBiasOffset, maxSteerAngle):
        self.carModel = carModel
        self.brakeBiasOffset = brakeBiasOffset
        self.maxSteerAngle = maxSteerAngle

carList = []
carList.append(Car("amr_v12_vantage_gt3",-7, 320))
carList.append(Car("audi_r8_lms",-14, 360))
carList.append(Car("bentley_continental_gt3_2016",-7, 320))
carList.append(Car("bentley_continental_gt3_2018",-7, 320))
carList.append(Car("bmw_m6_gt3",-15, 283))
carList.append(Car("jaguar_g3",-7, 360))
carList.append(Car("ferrari_488_gt3",-17, 240))
carList.append(Car("honda_nsx_gt3",-14, 310))
carList.append(Car("lamborghini_gallardo_rex",-14, 360))
carList.append(Car("lamborghini_huracan_gt3",-14, 310))
carList.append(Car("lamborghini_huracan_st",-14, 310))
carList.append(Car("lexus_rc_f_gt3",-14, 320))
carList.append(Car("mclaren_650s_gt3",-17, 240))
carList.append(Car("mercedes_amg_gt3",-14, 320))
carList.append(Car("nissan_gt_r_gt3_2017",-15, 320))
carList.append(Car("nissan_gt_r_gt3_2018",-15, 320))
carList.append(Car("porsche_991_gt3_r",-21, 400))
carList.append(Car("porsche_991ii_gt3_cup",-15, 400))
carList.append(Car("amr_v8_vantage_gt3",-7, 320))
carList.append(Car("audi_r8_lms_evo",-14, 360))
carList.append(Car("honda_nsx_gt3_evo",-14, 310))
carList.append(Car("lamborghini_huracan_gt3_evo",-14, 310))
carList.append(Car("mclaren_720s_gt3",-17, 240))
carList.append(Car("porsche_991ii_gt3_r",-21, 400))
carList.append(Car("alpine_a110_gt4",-15, 360))
carList.append(Car("amr_v8_vantage_gt4",-20, 320))
carList.append(Car("amr_v8_vantage_gt4",-20, 320))
carList.append(Car("amr_v8_vantage_gt4",-20, 320))
carList.append(Car("chevrolet_camaro_gt4r",-18, 360))
carList.append(Car("ginetta_g55_gt4",-18, 360))
carList.append(Car("ktm_xbow_gt4",-20, 290))
carList.append(Car("maserati_mc_gt4",-15, 450))
carList.append(Car("mclaren_570s_gt4",-9, 240))
carList.append(Car("mercedes_amg_gt4",-20, 246))
carList.append(Car("porsche_718_cayman_gt4_mr",-20, 400))


class SPageFileStatic2(Structure):
    _fields_ = [
        ("smVersion", c_wchar * 15),
        ("acVersion", c_wchar * 15),
        ("numberOfSessions", c_int),
        ("numCars", c_int),
        ("carModel", c_wchar * 33),
        ("track", c_wchar * 33),
        ("playerName", c_wchar * 33),
        ("playerSurname", c_wchar * 33),
        ("playerNick", c_wchar * 33),
    ]

class SPageFileStatic(Structure):
    _fields_ = [
        ("smVersion", c_wchar * 15),
        ("acVersion", c_wchar * 15),
        ("numberOfSessions", c_int),
        ("numCars", c_int),
        ("carModel", c_wchar * 33),
        ("track", c_wchar * 33),
        ("playerName", c_wchar * 33),
        ("playerSurname", c_wchar * 33),
        ("playerNick", c_wchar * 33),
        ("sectorCount", c_int),
        ("maxTorque", c_float),
        ("maxPower", c_float),
        ("maxRpm", c_int),
        ("maxFuel", c_float),
        ("suspensionMaxTravel", c_float * 4),
        ("tyreRadius", c_float * 4),
        ("maxTurboBoost", c_float),
        ("deprecated_1", c_float),
        ("deprecated_2", c_float),
        ("penaltiesEnabled", c_int),
        ("aidFuelRate", c_float),
        ("aidTireRate", c_float),
        ("aidMechanicalDamage", c_float),
        ("aidAllowTyreBlankets", c_int),
        ("aidStability", c_float),
        ("aidAutoClutch", c_int),
        ("aidAutoBlip", c_int),
        ("hasDRS", c_int),
        ("hasERS", c_int),
        ("hasKERS", c_int),
        ("kersMaxJ", c_float),
        ("engineBrakeSettingsCount", c_int),
        ("ersPowerControllerCount", c_int),
        ("trackSPlineLength", c_float),
        ("trackConfiguration", c_wchar * 33),
        ("ersMaxJ", c_float),
        ("isTimedRace", c_int),
        ("hasExtraLap", c_int),
        ("carSkin", c_wchar * 33),
        ("reversedGridPositions", c_int),
        ("PitWindowStart", c_int),
        ("PitWindowEnd", c_int),
        ("isOnline", c_int),
    ]


    def update(self):
            Report.Value['MaxFuel']=self.maxFuel
            Report.Value['MaxRPM']=self.maxRpm

class SPageFileGraphic(Structure):
    _fields_ = [
        ("packetId", c_int),
        ("AC_STATUS", c_int),
        ("AC_SESSION_TYPE", c_int),
        ("currentTime", c_wchar * 15),
        ("lastTime", c_wchar * 15),
        ("bestTime", c_wchar * 15),
        ("split", c_wchar * 15),
        ("completedLaps", c_int),
        ("position", c_int),
        ("iCurrentTime", c_int),
        ("iLastTime", c_int),
        ("iBestTime", c_int),
        ("sessionTimeLeft", c_float),
        ("distanceTraveled", c_float),
        ("isInPit", c_int),
        ("currentSectorIndex", c_int),
        ("lastSectorTime", c_int),
        ("numberOfLaps", c_int),
        ("tyreCompound", c_wchar * 33),
        ("replayTimeMultiplier", c_float),
        ("normalizedCarPosition", c_float),
        ("activeCars", c_int),
        ("carCoordinates", c_float * 60 * 3),
        ("carID", c_int * 60),
        ("playerCarID", c_int),
        ("penaltyTime", c_float),
        ("flag", c_int),
        ("penalty", c_int),
        ("idealLineOn", c_int),
        ("isInPitLane", c_int),
        ("surfaceGrip", c_float),
        ("mandatoryPitDone", c_int),
        ("windSpeed", c_float),
        ("windDirection", c_float),
        ("isSetupMenuVisible", c_int),
        ("mainDisplayIndex", c_int),
        ("secondaryDisplayIndex", c_int),
        ("TC", c_int),
        ("TCCut", c_int),
        ("EngineMap", c_int),
        ("ABS", c_int),
        ("fuelXLap", c_float),
        ("rainLights", c_int),
        ("flashingLights", c_int),
        ("lightsStage", c_int),
        ("exhaustTemperature", c_float),
        ("wiperLV", c_int),
        ("DriverStintTotalTimeLeft", c_int),
        ("DriverStintTimeLeft", c_int),
        ("rainTypes", c_int),
        ("sessionIndex", c_int),
        ("usedFuel", c_float),
        ("deltaLapTime", c_wchar * 15),
        ("iDeltaLapTime", c_int),
        ("estimatedLapTime", c_wchar * 15),
        ("iEstimatedLapTime", c_int),
        ("isDeltaPositive", c_int),
        ("iSplit", c_int),
        ("isValidLap", c_int),
        ("fuelEstimatedLaps", c_float),
        ("trackStatus", c_wchar * 33),
        ("missingMandatoryPits", c_int),
        ("directionLightsLeft", c_int),
        ("directionLightsRight", c_int),
    ]

    def update(self):
        #update Report here
        Report.Value['TC']=self.TC
        Report.Value['abs']=self.ABS


class SPageFilePhysics(Structure):
    _fields_ = [
        ("packetId", c_int),
        ("gas", c_float),
        ("brake", c_float),
        ("fuel", c_float),
        ("gear", c_int),                                                        # N = 1
        ("rpm", c_int),
        ("steerAngle", c_float),
        ("speedKmh", c_float),
        ("velocity", c_float * 3),
        ("accG", c_float * 3),
        ("wheelSlip", c_float * 4),
        ("wheelLoad", c_float * 4),
        ("wheelsPressure", c_float * 4),
        ("wheelAngularSpeed", c_float * 4),
        ("tyreWear", c_float * 4),
        ("tyreDirtyLevel", c_float * 4),
        ("tyreCoreTemperature", c_float * 4),
        ("camberRAD", c_float * 4),
        ("suspensionTravel", c_float * 4),
        ("drs", c_float),
        ("tc", c_float),
        ("heading", c_float),
        ("pitch", c_float),
        ("roll", c_float),
        ("cgHeight", c_float),
        ("carDamage", c_float * 5),
        ("numberOfTyresOut", c_int),
        ("pitLimiterOn", c_int),
        ("abs", c_float),
        ("kersCharge", c_float),
        ("kersInput", c_float),
        ("autoShifterOn", c_int),
        ("rideHeight", c_float * 2),
        ("turboBoost", c_float),
        ("ballast", c_float),
        ("airDensity", c_float),
        ("airTemp", c_float),
        ("roadTemp", c_float),
        ("localAngularVel", c_float * 3),
        ("finalFFB", c_float),
        ("performanceMeter", c_float),
        ("engineBrake", c_int),
        ("ersRecoveryLevel", c_int),
        ("ersPowerLevel", c_int),
        ("ersHeatCharging", c_int),
        ("ersIsCharging", c_int),
        ("kersCurrentKJ", c_float),
        ("drsAvailable", c_int),
        ("drsEnabled", c_int),
        ("brakeTemp", c_float * 4),
        ("clutch", c_float),
        ("tyreTempI", c_float * 4),
        ("tyreTempM", c_float * 4),
        ("tyreTempO", c_float * 4),
        ("isAIControlled", c_int),
        ("tyreContactPoint", c_float * 4 * 3),
        ("tyreContactNormal", c_float * 4 * 3),
        ("tyreContactHeading", c_float * 4 * 3),
        ("brakeBias", c_float),
        ("localVelocity", c_float * 3),
        ("P2PActivations", c_int),
        ("P2PStatus", c_int),
        ("currentMaxRpm", c_int),
        ("mz", c_float * 4),
        ("fx", c_float * 4),
        ("fy", c_float * 4),
        ("slipRatio", c_float * 4),
        ("slipAngle", c_float * 4),
        ("tcinAction", c_int),
        ("absInAction", c_int),
        ("suspensionDamage", c_float * 4),
        ("tyreTemp", c_float * 4),
        ("waterTemp", c_float),
        ("brakePressure", c_float * 4),
        ("frontBrakeCompound", c_int),
        ("rearBrakeCompound", c_int),
        ("padLife", c_float * 4),
        ("discLife", c_float * 4),
        ("ignitionOn", c_int),
        ("starterEngineOn", c_int),
        ("isEngineRunning", c_int),
        ("kerbVibration", c_float),
        ("slipVibrations", c_float),
        ("gVibrations", c_float),
        ("absVibrations", c_float),
    ]

    def update(self):
        Report.Value['Fuel']=self.fuel
        Report.Value['BrakeBias']=self.brakeBias
        Report.Value['Gear']=self.gear - 1
        Report.Value['FinalFFB']=self.finalFFB
        Report.Value['RPM']=self.rpm
        Report.Value['SpeedKmh']=self.speedKmh

def check_ac_acc():
    global connectedGame
    global ffbReport
    if connectedGame == RunningGame.NONE or connectedGame == RunningGame.AC_ACC:
        buf = mmap.mmap(-1, sizeof(SPageFileGraphic), u"Local\\acpmf_graphics")
        data = SPageFileGraphic.from_buffer(buf)
        if data.AC_STATUS == 2:
            vnmDataReport = converByteArrayToVnmDataReport(struct.unpack(vnm_data_format_string, Datas.Value["VNM_DATA_REPORT"]))
            connectedGame = RunningGame.AC_ACC
            #ac_acc_read_graphics()
            ffbReport.vnmTC = data.TC
            ffbReport.vnmTCCut = data.TCCut
            ffbReport.vnmABS = data.ABS
            ffbReport.VnmEngineMap = data.EngineMap
            ffbReport.vnmFuelXLap = round(data.fuelXLap*100)
            ffbReport.vnmFuelEstimatedLaps = round(data.fuelEstimatedLaps*100)
            #ac_acc_read_static()
            buf = mmap.mmap(-1, sizeof(SPageFileStatic), u"Local\\acpmf_static")
            data = SPageFileStatic.from_buffer(buf)
            ffbReport.vnmRpmMax = data.maxRpm
            ffbReport.vnmFuelMax = round(data.maxFuel*100)
            for car in carList:
                if car.carModel == data.carModel:
                    ffbReport.vnmBrakeBias = ffbReport.vnmBrakeBias + car.brakeBiasOffset*100
                    if ffbReport.vnmBrakeBias < 0:
                        ffbReport.vnmBrakeBias = 0
                    ffbReport.vnmMaxSteeringAngle = car.maxSteerAngle
            #ac_acc_read_physics()
            buf = mmap.mmap(-1, sizeof(SPageFilePhysics), u"Local\\acpmf_physics")
            data = SPageFilePhysics.from_buffer(buf)
            ffbReport.vnmSteeringAngle = round(data.steerAngle*10000)
            ffbReport.vnmFinalFFB =  round(data.finalFFB*10000)
            road_texture = round(((data.suspensionTravel[1]*1000000 - vnmDataReport.suspensionRight) - (data.suspensionTravel[0]*1000000 - vnmDataReport.suspensionLeft))*pluginConfig["RoadTextureGain"]/100)
            ffbReport.vnmFinalFFB += clamp(road_texture, -2000, 2000)
            vnmDataReport.suspensionLeft = data.suspensionTravel[0]*1000000
            vnmDataReport.suspensionRight  = data.suspensionTravel[1]*1000000
            ffbReport.vnmThrottle =  round(data.gas*10000)
            ffbReport.vnmBrake =  round(data.brake*10000)
            ffbReport.vnmClutch =  round(data.clutch*10000)
            ffbReport.vnmGear = data.gear
            if data.rpm > 0:
                ffbReport.vnmRpm = data.rpm
            ffbReport.vnmSpeedKmh = round(data.speedKmh)
            ffbReport.vnmBrakeBias = round(data.brakeBias*10000)
            ffbReport.VnmTCinAction = round(data.tc)
            ffbReport.VnmABSinAction = round(data.abs)
            ffbReport.vnmTurboBoost = round(data.turboBoost*10000)
            ffbReport.vnmPitLimiterOn = data.pitLimiterOn
            ffbReport.vnmIgnitionOn = data.ignitionOn
            ffbReport.vnmStarterEngineOn = data.starterEngineOn
            ffbReport.vnmIsEngineRunning = data.isEngineRunning
            ffbReport.vnmKerbVibration = round(data.kerbVibration*10000)
            ffbReport.vnmSlipVibrations = round(data.slipVibrations*10000)
            ffbReport.vnmGVibrations = round(data.gVibrations*10000)
            ffbReport.vnmAbsVibrations = round(data.absVibrations*10000)
            ffbReport.vnmFuel = round(data.fuel*100)
            Datas.Value["VNM_DATA_REPORT"] = vnmDataReport.to_bytes()
        else:
            connectedGame = RunningGame.NONE
        buf.close

############################################################################   iRacing Data     ##############################################################################################################
#this plugin use irsdk from https://github.com/kutu/pyirsdk
VERSION = '1.3.5'

SIM_STATUS_URL = 'http://127.0.0.1:32034/get_sim_status?object=simStatus'

DATAVALIDEVENTNAME = 'Local\\IRSDKDataValidEvent'
MEMMAPFILE = 'Local\\IRSDKMemMapFileName'
MEMMAPFILESIZE = 1164 * 1024
BROADCASTMSGNAME = 'IRSDK_BROADCASTMSG'

VAR_TYPE_MAP = ['c', '?', 'i', 'I', 'f', 'd']

YAML_TRANSLATER = bytes.maketrans(b'\x81\x8D\x8F\x90\x9D', b'     ')
YAML_CODE_PAGE = 'cp1252'

class StatusField:
    status_connected = 1

class EngineWarnings:
    water_temp_warning    = 0x01
    fuel_pressure_warning = 0x02
    oil_pressure_warning  = 0x04
    engine_stalled        = 0x08
    pit_speed_limiter     = 0x10
    rev_limiter_active    = 0x20
    oil_temp_warning      = 0x40

class Flags:
    # global flags
    checkered        = 0x0001
    white            = 0x0002
    green            = 0x0004
    yellow           = 0x0008
    red              = 0x0010
    blue             = 0x0020
    debris           = 0x0040
    crossed          = 0x0080
    yellow_waving    = 0x0100
    one_lap_to_green = 0x0200
    green_held       = 0x0400
    ten_to_go        = 0x0800
    five_to_go       = 0x1000
    random_waving    = 0x2000
    caution          = 0x4000
    caution_waving   = 0x8000

    # drivers black flags
    black      = 0x010000
    disqualify = 0x020000
    servicible = 0x040000 # car is allowed service (not a flag)
    furled     = 0x080000
    repair     = 0x100000

    # start lights
    start_hidden = 0x10000000
    start_ready  = 0x20000000
    start_set    = 0x40000000
    start_go     = 0x80000000

class TrkLoc:
    not_in_world    = -1
    off_track       = 0
    in_pit_stall    = 1
    aproaching_pits = 2
    on_track        = 3

class TrkSurf:
    not_in_world  = -1
    undefined     =  0
    asphalt_1     =  1
    asphalt_2     =  2
    asphalt_3     =  3
    asphalt_4     =  4
    concrete_1    =  5
    concrete_2    =  6
    racing_dirt_1 =  7
    racing_dirt_2 =  8
    paint_1       =  9
    paint_2       = 10
    rumble_1      = 11
    rumble_2      = 12
    rumble_3      = 13
    rumble_4      = 14
    grass_1       = 15
    grass_2       = 16
    grass_3       = 17
    grass_4       = 18
    dirt_1        = 19
    dirt_2        = 20
    dirt_3        = 21
    dirt_4        = 22
    sand          = 23
    gravel_1      = 24
    gravel_2      = 25
    grasscrete    = 26
    astroturf     = 27

class SessionState:
    invalid     = 0
    get_in_car  = 1
    warmup      = 2
    parade_laps = 3
    racing      = 4
    checkered   = 5
    cool_down   = 6

class CameraState:
    is_session_screen       = 0x0001 # the camera tool can only be activated if viewing the session screen (out of car)
    is_scenic_active        = 0x0002 # the scenic camera is active (no focus car)

    # these can be changed with a broadcast message
    cam_tool_active         = 0x0004
    ui_hidden               = 0x0008
    use_auto_shot_selection = 0x0010
    use_temporary_edits     = 0x0020
    use_key_acceleration    = 0x0040
    use_key10x_acceleration = 0x0080
    use_mouse_aim_mode      = 0x0100

class BroadcastMsg:
    cam_switch_pos             =  0 # car position, group, camera
    cam_switch_num             =  1 # driver #, group, camera
    cam_set_state              =  2 # CameraState, unused, unused
    replay_set_play_speed      =  3 # speed, slowMotion, unused
    replay_set_play_position   =  4 # RpyPosMode, Frame Number (high, low)
    replay_search              =  5 # RpySrchMode, unused, unused
    replay_set_state           =  6 # RpyStateMode, unused, unused
    reload_textures            =  7 # ReloadTexturesMode, carIdx, unused
    chat_command               =  8 # ChatCommandMode, subCommand, unused
    pit_command                =  9 # PitCommandMode, parameter
    telem_command              = 10 # irsdk_TelemCommandMode, unused, unused
    ffb_command                = 11 # irsdk_FFBCommandMode, value (float, high, low)
    replay_search_session_time = 12 # sessionNum, sessionTimeMS (high, low)
    video_capture              = 13 # irsdk_VideoCaptureMode, unused, unused

class ChatCommandMode:
    macro      = 0 # pass in a number from 1-15 representing the chat macro to launch
    begin_chat = 1 # Open up a new chat window
    reply      = 2 # Reply to last private chat
    cancel     = 3 # Close chat window

class PitCommandMode: # this only works when the driver is in the car
    clear       =  0 # Clear all pit checkboxes
    ws          =  1 # Clean the winshield, using one tear off
    fuel        =  2 # Add fuel, optionally specify the amount to add in liters or pass '0' to use existing amount
    lf          =  3 # Change the left front tire, optionally specifying the pressure in KPa or pass '0' to use existing pressure
    rf          =  4 # right front
    lr          =  5 # left rear
    rr          =  6 # right rear
    clear_tires =  7 # Clear tire pit checkboxes
    fr          =  8 # Request a fast repair
    clear_ws    =  9 # Uncheck Clean the winshield checkbox
    clear_fr    = 10 # Uncheck request a fast repair
    clear_fuel  = 11 # Uncheck add fuel

class TelemCommandMode: # You can call this any time, but telemtry only records when driver is in there car
    stop    = 0 # Turn telemetry recording off
    start   = 1 # Turn telemetry recording on
    restart = 2 # Write current file to disk and start a new one

class RpyStateMode:
    erase_tape = 0 # clear any data in the replay tape

class ReloadTexturesMode:
    all     = 0 # reload all textuers
    car_idx = 1 # reload only textures for the specific carIdx

class RpySrchMode:
    to_start      = 0
    to_end        = 1
    prev_session  = 2
    next_session  = 3
    prev_lap      = 4
    next_lap      = 5
    prev_frame    = 6
    next_frame    = 7
    prev_incident = 8
    next_incident = 9

class RpyPosMode:
    begin   = 0
    current = 1
    end     = 2

class csMode:
    at_incident = -3
    at_leader   = -2
    at_exciting = -1

class PitSvFlags:
    lf_tire_change     = 0x01
    rf_tire_change     = 0x02
    lr_tire_change     = 0x04
    rr_tire_change     = 0x08
    fuel_fill          = 0x10
    windshield_tearoff = 0x20
    fast_repair        = 0x40

class PitSvStatus:
    # status
    none            = 0
    in_progress     = 1
    complete        = 2
    # errors
    too_far_left    = 100
    too_far_right   = 101
    too_far_forward = 102
    too_far_back    = 103
    bad_angle       = 104
    cant_fix_that   = 105

class PaceMode:
    single_file_start   = 0
    double_file_start   = 1
    single_file_restart = 2
    double_file_restart = 3
    not_pacing          = 4

class PaceFlags:
    end_of_line  = 0x0001
    free_pass    = 0x0002
    waved_around = 0x0004

class CarLeftRight:
    off            = 0
    clear          = 1 # no cars around us.
    car_left       = 2 # there is a car to our left.
    car_right      = 3 # there is a car to our right.
    car_left_right = 4 # there are cars on each side.
    two_cars_left  = 5 # there are two cars to our left.
    two_cars_right = 6 # there are two cars to our right.

class FFBCommandMode: # You can call this any time
    ffb_command_max_force = 0 # Set the maximum force when mapping steering torque force to direct input units (float in Nm)

class VideoCaptureMode:
    trigger_screen_shot   = 0 # save a screenshot to disk
    start_video_capture   = 1 # start capturing video
    end_video_capture     = 2 # stop capturing video
    toggle_video_capture  = 3 # toggle video capture on/off
    show_video_timer      = 4 # show video timer in upper left corner of display
    hide_video_timer      = 5 # hide video timer

class TrackWetness:
    unknown          = 0
    dry              = 1
    mostly_dry       = 2
    very_lightly_wet = 3
    lightly_wet      = 4
    moderately_wet   = 5
    very_wet         = 6
    extremely_wet    = 7


class IRSDKStruct:
    @classmethod
    def property_value(cls, offset, var_type):
        struct_type = struct.Struct(var_type)
        return property(lambda self: self.get(offset, struct_type))

    @classmethod
    def property_value_str(cls, offset, var_type):
        struct_type = struct.Struct(var_type)
        return property(lambda self: self.get(offset, struct_type).strip(b'\x00').decode('latin-1'))

    def __init__(self, shared_mem, offset=0):
        self._shared_mem = shared_mem
        self._offset = offset

    def __repr__(self):
        return f'''<{self.__class__.__module__}.{self.__class__.__name__} {', '.join(
                f'{k}={getattr(self, k)!r}'
                for k, p in vars(self.__class__).items()
                if not k.startswith('_') and isinstance(p, property)
            )}>'''

    def get(self, offset, struct_type):
        return struct_type.unpack_from(self._shared_mem, self._offset + offset)[0]

class Header(IRSDKStruct):
    version = IRSDKStruct.property_value(0, 'i')
    status = IRSDKStruct.property_value(4, 'i')
    tick_rate = IRSDKStruct.property_value(8, 'i')

    session_info_update = IRSDKStruct.property_value(12, 'i')
    session_info_len = IRSDKStruct.property_value(16, 'i')
    session_info_offset = IRSDKStruct.property_value(20, 'i')

    num_vars = IRSDKStruct.property_value(24, 'i')
    var_header_offset = IRSDKStruct.property_value(28, 'i')

    num_buf = IRSDKStruct.property_value(32, 'i')
    buf_len = IRSDKStruct.property_value(36, 'i')

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self.var_buf = [
            VarBuffer(self._shared_mem, 48 + i * 16, buf_len=self.buf_len)
            for i in range(self.num_buf)
        ]

class VarBuffer(IRSDKStruct):
    tick_count = IRSDKStruct.property_value(0, 'i')
    _buf_offset = IRSDKStruct.property_value(4, 'i')

    def __init__(self, *args, buf_len, **kwargs):
        super().__init__(*args, **kwargs)
        self.is_memory_frozen = False
        self._frozen_memory = None
        self._buf_len = buf_len

    def freeze(self):
        self._frozen_memory = self._shared_mem[self._buf_offset : self._buf_offset + self._buf_len]
        self.is_memory_frozen = True

    def unfreeze(self):
        self._frozen_memory = None
        self.is_memory_frozen = False

    def get_memory(self):
        return self._frozen_memory if self.is_memory_frozen else self._shared_mem

    @property
    def buf_offset(self):
        return 0 if self.is_memory_frozen else self._buf_offset

class VarHeader(IRSDKStruct):
    type = IRSDKStruct.property_value(0, 'i')
    offset = IRSDKStruct.property_value(4, 'i')
    count = IRSDKStruct.property_value(8, 'i')
    count_as_time = IRSDKStruct.property_value(12, '?')
    name = IRSDKStruct.property_value_str(16, '32s')
    desc = IRSDKStruct.property_value_str(48, '64s')
    unit = IRSDKStruct.property_value_str(112, '32s')

class DiskSubHeader(IRSDKStruct):
    session_start_date = IRSDKStruct.property_value(0, 'Q')
    session_start_time = IRSDKStruct.property_value(8, 'd')
    session_end_time = IRSDKStruct.property_value(16, 'd')
    session_lap_count = IRSDKStruct.property_value(24, 'i')
    session_record_count = IRSDKStruct.property_value(28, 'i')

class IRSDK:
    def __init__(self, parse_yaml_async=False):
        self.parse_yaml_async = parse_yaml_async
        self.is_initialized = False
        self.last_session_info_update = 0

        self._shared_mem = None
        self._header = None
        self._data_valid_event = None

        self.__var_headers = None
        self.__var_headers_dict = None
        self.__var_headers_names = None
        self.__var_buffer_latest = None
        self.__session_info_dict = {}
        self.__broadcast_msg_id = None
        self.__test_file = None
        self.__workaround_connected_state = 0

    def __getitem__(self, key):
        if key in self._var_headers_dict:
            var_header = self._var_headers_dict[key]
            var_buf_latest = self._var_buffer_latest
            res = struct.unpack_from(
                VAR_TYPE_MAP[var_header.type] * var_header.count,
                var_buf_latest.get_memory(),
                var_buf_latest.buf_offset + var_header.offset)
            return res[0] if var_header.count == 1 else list(res)

        return self._get_session_info(key)

    @property
    def is_connected(self):
        if self._header:
            if self._header.status == StatusField.status_connected:
                self.__workaround_connected_state = 0
            if self.__workaround_connected_state == 0 and self._header.status != StatusField.status_connected:
                self.__workaround_connected_state = 1
            if self.__workaround_connected_state == 1 and (self['SessionNum'] is None or self.__test_file):
                self.__workaround_connected_state = 2
            if self.__workaround_connected_state == 2 and self['SessionNum'] is not None:
                self.__workaround_connected_state = 3
        return self._header is not None and \
            (self.__test_file or self._data_valid_event) and \
            (self._header.status == StatusField.status_connected or self.__workaround_connected_state == 3)

    @property
    def session_info_update(self):
        return self._header.session_info_update

    @property
    def var_headers_names(self):
        if self.__var_headers_names is None:
            self.__var_headers_names = [var_header.name for var_header in self._var_headers]
        return self.__var_headers_names

    def startup(self, test_file=None, dump_to=None):
        if test_file is None:
            if not self._check_sim_status():
                return False
            self._data_valid_event = ctypes.windll.kernel32.OpenEventW(0x00100000, False, DATAVALIDEVENTNAME)
        if not self._wait_valid_data_event():
            self._data_valid_event = None
            return False

        if self._shared_mem is None:
            if test_file:
                self.__test_file = open(test_file, 'rb')
                self._shared_mem = mmap.mmap(self.__test_file.fileno(), 0, access=mmap.ACCESS_READ)
            else:
                self._shared_mem = mmap.mmap(0, MEMMAPFILESIZE, MEMMAPFILE, access=mmap.ACCESS_READ)

        if self._shared_mem:
            if dump_to:
                with open(dump_to, 'wb') as f:
                    f.write(self._shared_mem)
            self._header = Header(self._shared_mem)
            self.is_initialized = self._header.version >= 1 and len(self._header.var_buf) > 0

        return self.is_initialized

    def shutdown(self):
        self.is_initialized = False
        self.last_session_info_update = 0
        if self._shared_mem:
            self._shared_mem.close()
            self._shared_mem = None
        self._header = None
        self._data_valid_event = None
        self.__var_headers = None
        self.__var_headers_dict = None
        self.__var_headers_names = None
        self.__var_buffer_latest = None
        self.__session_info_dict = {}
        self.__broadcast_msg_id = None
        if self.__test_file:
            self.__test_file.close()
            self.__test_file = None

    def parse_to(self, to_file):
        if not self.is_initialized:
            return
        f = open(to_file, 'w', encoding='utf-8')
        f.write(self._shared_mem[self._header.session_info_offset:self._header.session_info_len].rstrip(b'\x00').decode(YAML_CODE_PAGE))
        f.write('\n'.join([
            '{:32}{}'.format(i, self[i])
            for i in sorted(self._var_headers_dict.keys(), key=str.lower)
        ]))
        f.close()

    def cam_switch_pos(self, position=0, group=1, camera=0):
        return self._broadcast_msg(BroadcastMsg.cam_switch_pos, position, group, camera)

    def cam_switch_num(self, car_number='1', group=1, camera=0):
        return self._broadcast_msg(BroadcastMsg.cam_switch_num, self._pad_car_num(car_number), group, camera)

    def cam_set_state(self, camera_state=CameraState.cam_tool_active):
        return self._broadcast_msg(BroadcastMsg.cam_set_state, camera_state)

    def replay_set_play_speed(self, speed=0, slow_motion=False):
        return self._broadcast_msg(BroadcastMsg.replay_set_play_speed, speed, 1 if slow_motion else 0)

    def replay_set_play_position(self, pos_mode=RpyPosMode.begin, frame_num=0):
        return self._broadcast_msg(BroadcastMsg.replay_set_play_position, pos_mode, frame_num)

    def replay_search(self, search_mode=RpySrchMode.to_start):
        return self._broadcast_msg(BroadcastMsg.replay_search, search_mode)

    def replay_set_state(self, state_mode=RpyStateMode.erase_tape):
        return self._broadcast_msg(BroadcastMsg.replay_set_state, state_mode)

    def reload_all_textures(self):
        return self._broadcast_msg(BroadcastMsg.reload_textures, ReloadTexturesMode.all)

    def reload_texture(self, car_idx=0):
        return self._broadcast_msg(BroadcastMsg.reload_textures, ReloadTexturesMode.car_idx, car_idx)

    def chat_command(self, chat_command_mode=ChatCommandMode.begin_chat):
        return self._broadcast_msg(BroadcastMsg.chat_command, chat_command_mode)

    def chat_command_macro(self, macro_num=0):
        return self._broadcast_msg(BroadcastMsg.chat_command, ChatCommandMode.macro, macro_num)

    def pit_command(self, pit_command_mode=PitCommandMode.clear, var=0):
        return self._broadcast_msg(BroadcastMsg.pit_command, pit_command_mode, var)

    def telem_command(self, telem_command_mode=TelemCommandMode.stop):
        return self._broadcast_msg(BroadcastMsg.telem_command, telem_command_mode)

    def ffb_command(self, ffb_command_mode=FFBCommandMode.ffb_command_max_force, value=0):
        return self._broadcast_msg(BroadcastMsg.ffb_command, ffb_command_mode, int(value * 65536))

    def replay_search_session_time(self, session_num=0, session_time_ms=0):
        return self._broadcast_msg(BroadcastMsg.replay_search_session_time, session_num, session_time_ms)

    def video_capture(self, video_capture_mode=VideoCaptureMode.trigger_screen_shot):
        return self._broadcast_msg(BroadcastMsg.video_capture, video_capture_mode)

    def _check_sim_status(self):
        try:
            return 'running:1' in request.urlopen(SIM_STATUS_URL).read().decode('utf-8')
        except error.URLError as e:
            print("Failed to connect to sim: {}".format(e.reason))
            return False

    @property
    def _var_buffer_latest(self):
        # return 2nd most recent var buffer
        # because it might be a situation (with most recent var buffer)
        # that half of var buffer written with new data
        # and other half still old
        return sorted(self._header.var_buf, key=lambda v: v.tick_count, reverse=True)[1]

    @property
    def _var_headers(self):
        if self.__var_headers is None:
            self.__var_headers = []
            for i in range(self._header.num_vars):
                var_header = VarHeader(self._shared_mem, self._header.var_header_offset + i * 144)
                self._var_headers.append(var_header)
        return self.__var_headers

    @property
    def _var_headers_dict(self):
        if self.__var_headers_dict is None:
            self.__var_headers_dict = {}
            for var_header in self._var_headers:
                self.__var_headers_dict[var_header.name] = var_header
        return self.__var_headers_dict

    def freeze_var_buffer_latest(self):
        self.unfreeze_var_buffer_latest()
        self._wait_valid_data_event()
        self.__var_buffer_latest = sorted(self._header.var_buf, key=lambda v: v.tick_count, reverse=True)[0]
        self.__var_buffer_latest.freeze()

    def unfreeze_var_buffer_latest(self):
        if self.__var_buffer_latest:
            self.__var_buffer_latest.unfreeze()
            self.__var_buffer_latest = None

    def get_session_info_update_by_key(self, key):
        if key in self.__session_info_dict:
            return self.__session_info_dict[key]['update']
        return None

    def _wait_valid_data_event(self):
        if self._data_valid_event is not None:
            return ctypes.windll.kernel32.WaitForSingleObject(self._data_valid_event, 32) == 0 if self._data_valid_event else False
        else:
            return True

    def _get_session_info(self, key):
        if self.last_session_info_update < self._header.session_info_update:
            self.last_session_info_update = self._header.session_info_update
            for session_data in self.__session_info_dict.values():
                # keep previous parsed data, in case binary data not changed
                if session_data['data']:
                    session_data['data_last'] = session_data['data']
                session_data['data'] = None

        if key not in self.__session_info_dict:
            self.__session_info_dict[key] = dict(data=None)

        session_data = self.__session_info_dict[key]

        # already have and parsed
        if session_data['data']:
            return session_data['data']

        if self.parse_yaml_async:
            if 'async_session_info_update' not in session_data or session_data['async_session_info_update'] < self.last_session_info_update:
                session_data['async_session_info_update'] = self.last_session_info_update
                Thread(target=self._parse_yaml, args=(key, session_data)).start()
        else:
            self._parse_yaml(key, session_data)
        return session_data['data']

    def _get_session_info_binary(self, key):
        start = self._header.session_info_offset
        end = start + self._header.session_info_len
        # search section by key
        match_start = re.compile(('\n%s:\n' % key).encode(YAML_CODE_PAGE)).search(self._shared_mem, start, end)
        if not match_start:
            return None
        match_end = re.compile(b'\n\n').search(self._shared_mem, match_start.start() + 1, end)
        if not match_end:
            return None
        return self._shared_mem[match_start.start() + 1 : match_end.start()]

    def _parse_yaml(self, key, session_data):
        session_info_update = self.last_session_info_update
        data_binary = self._get_session_info_binary(key)

        # section not found
        if not data_binary:
            if 'data_last' in session_data:
                return session_data['data_last']
            else:
                return None

        # is binary data the same as last time?
        if 'data_binary' in session_data and data_binary == session_data['data_binary'] and 'data_last' in session_data:
            session_data['data'] = session_data['data_last']
            return session_data['data']
        session_data['data_binary'] = data_binary

        # parsing
        yaml_src = re.sub(YamlReader.NON_PRINTABLE, '', data_binary.translate(YAML_TRANSLATER).rstrip(b'\x00').decode(YAML_CODE_PAGE))
        if key == 'DriverInfo':
            def name_replace(m):
                return m.group(1) + '"%s"' % re.sub(r'(["\\])', r'\\\1', m.group(2) or m.group(3))
            yaml_src = re.sub(r'((?:DriverSetupName|UserName|TeamName|AbbrevName|Initials): )(?:"(.*)"$|(.+))', name_replace, yaml_src, flags=re.M)
        yaml_src = re.sub(r'(\w+: )(,.*)', r'\1"\2"', yaml_src)
        result = yaml.load(yaml_src, Loader=CustomYamlSafeLoader)
        # check if result is available, and yaml data is not updated while we were parsing it in async mode
        if result and (not self.parse_yaml_async or self.last_session_info_update == session_info_update):
            session_data['data'] = result[key]
            if session_data['data']:
                session_data['update'] = session_info_update
            elif 'data_last' in session_data:
                session_data['data'] = session_data['data_last']

    @property
    def _broadcast_msg_id(self):
        if self.__broadcast_msg_id is None:
            self.__broadcast_msg_id = ctypes.windll.user32.RegisterWindowMessageW(BROADCASTMSGNAME)
        return self.__broadcast_msg_id

    def _broadcast_msg(self, broadcast_type=0, var1=0, var2=0, var3=0):
        return ctypes.windll.user32.SendNotifyMessageW(0xFFFF, self._broadcast_msg_id,
            broadcast_type | var1 << 16, var2 | var3 << 16)

    def _pad_car_num(self, num):
        num = str(num)
        num_len = len(num)
        zero = num_len - len(num.lstrip("0"))
        if zero > 0 and num_len == zero:
            zero -= 1
        num = int(num)
        if zero:
            num_place = 3 if num > 99 else 2 if num > 9 else 1
            return num + 1000 * (num_place + zero)
        return num

class IBT:
    def __init__(self):
        self._ibt_file = None
        self._shared_mem = None
        self._header = None
        self._disk_header = None

        self.__var_headers = None
        self.__var_headers_dict = None
        self.__var_headers_names = None
        self.__session_info_dict = None

    def __getitem__(self, key):
        return self.get(self._disk_header.session_record_count - 1, key)

    @property
    def file_name(self):
        return self._ibt_file and self._ibt_file.name

    @property
    def var_header_buffer_tick(self):
        return self._header and self._header.var_buf[0].tick_count

    @property
    def var_headers_names(self):
        if not self._header:
            return None
        if self.__var_headers_names is None:
            self.__var_headers_names = [var_header.name for var_header in self._var_headers]
        return self.__var_headers_names

    def open(self, ibt_file):
        self._ibt_file = open(ibt_file, 'rb')
        self._shared_mem = mmap.mmap(self._ibt_file.fileno(), 0, access=mmap.ACCESS_READ)
        self._header = Header(self._shared_mem)
        self._disk_header = DiskSubHeader(self._shared_mem, 112)

    def close(self):
        if self._shared_mem:
            self._shared_mem.close()

        if self._ibt_file:
            self._ibt_file.close()

        self._ibt_file = None
        self._shared_mem = None
        self._header = None
        self._disk_header = None

        self.__var_headers = None
        self.__var_headers_dict = None
        self.__var_headers_names = None
        self.__session_info_dict = None

    def get(self, index, key):
        if not self._header:
            return None
        if 0 > index >= self._disk_header.session_record_count:
            return None
        if key in self._var_headers_dict:
            var_header = self._var_headers_dict[key]
            fmt = VAR_TYPE_MAP[var_header.type] * var_header.count
            var_offset = var_header.offset + self._header.var_buf[0].buf_offset + index * self._header.buf_len
            res = struct.unpack_from(fmt, self._shared_mem, var_offset)
            return list(res) if var_header.count > 1 else res[0]
        return None

    def get_all(self, key):
        if not self._header:
            return None
        if key in self._var_headers_dict:
            var_header = self._var_headers_dict[key]
            fmt = VAR_TYPE_MAP[var_header.type] * var_header.count
            var_offset = var_header.offset + self._header.var_buf[0].buf_offset
            buf_len = self._header.buf_len
            is_array = var_header.count > 1
            results = []
            for i in range(self._disk_header.session_record_count):
                res = struct.unpack_from(fmt, self._shared_mem, var_offset + i * buf_len)
                results.append(list(res) if is_array else res[0])
            return results
        return None

    @property
    def _var_headers(self):
        if not self._header:
            return None
        if self.__var_headers is None:
            self.__var_headers = []
            for i in range(self._header.num_vars):
                var_header = VarHeader(self._shared_mem, self._header.var_header_offset + i * 144)
                self._var_headers.append(var_header)
        return self.__var_headers

    @property
    def _var_headers_dict(self):
        if not self._header:
            return None
        if self.__var_headers_dict is None:
            self.__var_headers_dict = {}
            for var_header in self._var_headers:
                self.__var_headers_dict[var_header.name] = var_header
        return self.__var_headers_dict

# https://stackoverflow.com/a/37958106/1034242
class CustomYamlSafeLoader(YamlSafeLoader):
    @classmethod
    def remove_implicit_resolver(cls, tag_to_remove):
        if not 'yaml_implicit_resolvers' in cls.__dict__:
            cls.yaml_implicit_resolvers = cls.yaml_implicit_resolvers.copy()
        for first_letter, mappings in cls.yaml_implicit_resolvers.items():
            cls.yaml_implicit_resolvers[first_letter] = [(tag, regexp) for tag, regexp in mappings if tag != tag_to_remove]
CustomYamlSafeLoader.remove_implicit_resolver('tag:yaml.org,2002:timestamp')

class State:
    ir_connected = False
    last_car_setup_tick = -1
ir = IRSDK()
state = State()
def check_iracing():
    global connectedGame
    global ffbReport
    if connectedGame == RunningGame.NONE or connectedGame == RunningGame.IRACING:
        if state.ir_connected and not (ir.is_initialized and ir.is_connected):
            state.ir_connected = False
            # don't forget to reset your State variables
            state.last_car_setup_tick = -1
            # we are shutting down ir library (clearing all internal variables)
            ir.shutdown()
            print('irsdk disconnected')
        elif not state.ir_connected and ir.startup() and ir.is_initialized and ir.is_connected:
            state.ir_connected = True
            print('irsdk connected')
        if state.ir_connected:
            connectedGame = RunningGame.IRACING
            vnmDataReport = converByteArrayToVnmDataReport(struct.unpack(vnm_data_format_string, Datas.Value["VNM_DATA_REPORT"]))
            if ir['SteeringWheelAngleMax'] > 0:
                maxAngle = ir['SteeringWheelAngleMax']
            else:
                maxAngle = 7.85398
            ffbReport.vnmSteeringAngle = -round(ir['SteeringWheelAngle']/maxAngle*10000)
            reducedAngle =round(pluginConfig["ForceReductionThresholdDeg"]/maxAngle*174.533)
            if ffbReport.vnmSteeringAngle > 0 and ffbReport.vnmSteeringAngle < reducedAngle:
                ffbReport.vnmFinalFFB = round(map_value(ffbReport.vnmSteeringAngle, 0, reducedAngle, ir['SteeringWheelPctTorqueSignStops'] * 100 * pluginConfig["ForceReductionFactor"], ir['SteeringWheelPctTorqueSignStops']*10000))
            elif ffbReport.vnmSteeringAngle < 0 and ffbReport.vnmSteeringAngle > -reducedAngle:
                ffbReport.vnmFinalFFB = round(map_value(ffbReport.vnmSteeringAngle, -reducedAngle, 0, ir['SteeringWheelPctTorqueSignStops']*10000, ir['SteeringWheelPctTorqueSignStops'] * 100 * pluginConfig["ForceReductionFactor"]))
            else:
                ffbReport.vnmFinalFFB = round(ir['SteeringWheelPctTorqueSignStops']*10000)
            try:
                road_texture = round((ir['RFshockVel'][0]*10000 - vnmDataReport.suspensionRight - ir['LFshockVel'][0]*10000 + vnmDataReport.suspensionLeft) * pluginConfig["RoadTextureGain"]/100)
                vnmDataReport.suspensionRight = ir['RFshockVel'][0]*10000
                vnmDataReport.suspensionLeft = ir['LFshockVel'][0]*10000
            except:
                road_texture = 0
            Datas.Value["VNM_DATA_REPORT"] = vnmDataReport.to_bytes()
            ffbReport.vnmFinalFFB += clamp(road_texture, -2000, 2000)
            ffbReport.vnmThrottle =  round(ir['Throttle']*10000)
            ffbReport.vnmBrake =  round(ir['Brake']*10000)
            ffbReport.vnmClutch =  round(ir['Clutch']*10000)
            ffbReport.vnmGear = round(ir['Gear'])
            ffbReport.vnmRpm = round(ir['RPM'])
            ffbReport.vnmSpeedKmh = round(ir['Speed']*3.6)
            ffbReport.vnmFuel = round(ir['FuelLevel'])
            #ffbReport.VnmTCinAction = 0
            #ffbReport.VnmABSinAction = 0
            #ffbReport.vnmTurboBoost = 0
            #ffbReport.vnmPitLimiterOn = 0
            #ffbReport.vnmIgnitionOn = 0
            #ffbReport.vnmStarterEngineOn = 0
            #ffbReport.vnmIsEngineRunning = 0
            #ffbReport.vnmKerbVibration = 0
            #ffbReport.vnmSlipVibrations = 0
            #ffbReport.vnmGVibrations = 0
            #ffbReport.vnmAbsVibrations = 0
            #ffbReport.vnmRpmMax = 0
            #ffbReport.vnmFuelMax = 0
            #ffbReport.vnmTC = 0
            #ffbReport.vnmTCCut = 0
            #ffbReport.vnmABS = 0
            #ffbReport.VnmEngineMap = 0
            #ffbReport.vnmFuelXLap = 0
            #ffbReport.vnmFuelEstimatedLaps = 0
            Datas.Value["VNM_DATA_REPORT"] = vnmDataReport.to_bytes()
        else:
            connectedGame = RunningGame.NONE
            #ir.shutdown()


##################################################################################### RF2/LMU ###########################################################################################

#https://github.com/s-victor/pyRfactor2SharedMemory/tree/master
#Python mapping of The Iron Wolf's rF2 Shared Memory Tools
#Auto-generated from rF2data.cs
class rFactor2Constants:
  MAX_MAPPED_VEHICLES = 128
  MAX_MAPPED_IDS = 512
  MAX_RULES_INSTRUCTION_MSG_LEN = 96
  MAX_STATUS_MSG_LEN = 128
  MAX_HWCONTROL_NAME_LEN = 96


"""

#untranslated /*
rF2 internal state mapping structures.  Allows access to native C++ structs from C
#untranslated Must be kept in sync with Include\rF2State.h.
#untranslated See: MainForm.MainUpdate for sample on how to marshall from native in memory struct.
#untranslated Author: The Iron Wolf (vleonavicius@hotmail.com)
#untranslated Website: thecrewchief.org
#untranslated */
#untranslated using Newtonsoft.Json;
#untranslated using System;
#untranslated using System.Runtime.InteropServices;
#untranslated using System.Xml.Serialization;
#untranslated namespace rF2SharedMemory
class rFactor2Constants
        const string MM_TELEMETRY_FILE_NAME = "$rFactor2SMMP_Telemetry$";
        const string MM_SCORING_FILE_NAME = "$rFactor2SMMP_Scoring$";
        const string MM_RULES_FILE_NAME = "$rFactor2SMMP_Rules$";
        const string MM_FORCE_FEEDBACK_FILE_NAME = "$rFactor2SMMP_ForceFeedback$";
        const string MM_GRAPHICS_FILE_NAME = "$rFactor2SMMP_Graphics$";
        const string MM_PITINFO_FILE_NAME = "$rFactor2SMMP_PitInfo$";
        const string MM_WEATHER_FILE_NAME = "$rFactor2SMMP_Weather$";
        const string MM_EXTENDED_FILE_NAME = "$rFactor2SMMP_Extended$";
        const string MM_HWCONTROL_FILE_NAME = "$rFactor2SMMP_HWControl$";
        const int MM_HWCONTROL_LAYOUT_VERSION = 1;
        const string MM_WEATHER_CONTROL_FILE_NAME = "$rFactor2SMMP_WeatherControl$";
        const int MM_WEATHER_CONTROL_LAYOUT_VERSION = 1;
        const int MAX_MAPPED_VEHICLES = 128;
        const int MAX_MAPPED_IDS = 512;
        const int MAX_STATUS_MSG_LEN = 128;
        const int MAX_RULES_INSTRUCTION_MSG_LEN = 96;
        const int MAX_HWCONTROL_NAME_LEN = 96;
        const string RFACTOR2_PROCESS_NAME = "rFactor2";
        const byte RowX = 0;
        const byte RowY = 1;
        const byte RowZ = 2;
"""
class rF2GamePhase(Enum):
        Garage = 0
        WarmUp = 1
        GridWalk = 2
        Formation = 3
        Countdown = 4
        GreenFlag = 5
        FullCourseYellow = 6
        SessionStopped = 7
        SessionOver = 8
        PausedOrHeartbeat = 9

class rF2YellowFlagState(Enum):
        Invalid = -1
        NoFlag = 0
        Pending = 1
        PitClosed = 2
        PitLeadLap = 3
        PitOpen = 4
        LastLap = 5
        Resume = 6
        RaceHalt = 7

class rF2SurfaceType(Enum):
        Dry = 0
        Wet = 1
        Grass = 2
        Dirt = 3
        Gravel = 4
        Kerb = 5
        Special = 6

class rF2Sector(Enum):
        Sector3 = 0
        Sector1 = 1
        Sector2 = 2

class rF2FinishStatus(Enum):
        _None = 0
        Finished = 1
        Dnf = 2
        Dq = 3

class rF2Control(Enum):
        Nobody = -1
        Player = 0
        AI = 1
        Remote = 2
        Replay = 3

class rF2WheelIndex(Enum):
        FrontLeft = 0
        FrontRight = 1
        RearLeft = 2
        RearRight = 3

class rF2PitState(Enum):
        _None = 0
        Request = 1
        Entering = 2
        Stopped = 3
        Exiting = 4

class rF2PrimaryFlag(Enum):
        Green = 0
        Blue = 6

class rF2CountLapFlag(Enum):
        DoNotCountLap = 0
        CountLapButNotTime = 1
        CountLapAndTime = 2

class rF2RearFlapLegalStatus(Enum):
        Disallowed = 0
        DetectedButNotAllowedYet = 1
        Alllowed = 2

class rF2IgnitionStarterStatus(Enum):
        Off = 0
        Ignition = 1
        IgnitionAndStarter = 2

class rF2SafetyCarInstruction(Enum):
        NoChange = 0
        GoActive = 1
        HeadForPits = 2


#untranslated namespace rFactor2Data
#untranslated [StructLayout(LayoutKind.Sequential, Pack = 4)]
class rF2Vec3(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('x', ctypes.c_double),
        ('y', ctypes.c_double),
        ('z', ctypes.c_double),
]

#untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2Wheel(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mSuspensionDeflection', ctypes.c_double),                         # meters
        ('mRideHeight', ctypes.c_double),                                   # meters
        ('mSuspForce', ctypes.c_double),                                    # pushrod load in Newtons
        ('mBrakeTemp', ctypes.c_double),                                    # Celsius
        ('mBrakePressure', ctypes.c_double),                                # currently 0.0-1.0, depending on driver input and brake balance; will convert to true brake pressure (kPa) in future
        ('mRotation', ctypes.c_double),                                     # radians/sec
        ('mLateralPatchVel', ctypes.c_double),                              # lateral velocity at contact patch
        ('mLongitudinalPatchVel', ctypes.c_double),                         # longitudinal velocity at contact patch
        ('mLateralGroundVel', ctypes.c_double),                             # lateral velocity at contact patch
        ('mLongitudinalGroundVel', ctypes.c_double),                        # longitudinal velocity at contact patch
        ('mCamber', ctypes.c_double),                                       # radians (positive is left for left-side wheels, right for right-side wheels)
        ('mLateralForce', ctypes.c_double),                                 # Newtons
        ('mLongitudinalForce', ctypes.c_double),                            # Newtons
        ('mTireLoad', ctypes.c_double),                                     # Newtons
        ('mGripFract', ctypes.c_double),                                    # an approximation of what fraction of the contact patch is sliding
        ('mPressure', ctypes.c_double),                                     # kPa (tire pressure)
        ('mTemperature', ctypes.c_double*3),                                # Kelvin (subtract 273.15 to get Celsius), left/center/right (not to be confused with inside/center/outside!)
        ('mWear', ctypes.c_double),                                         # wear (0.0-1.0, fraction of maximum) ... this is not necessarily proportional with grip loss
        ('mTerrainName', ctypes.c_char*16),                                  # the material prefixes from the TDF file
        ('mSurfaceType', ctypes.c_ubyte),                                    # 0=dry, 1=wet, 2=grass, 3=dirt, 4=gravel, 5=rumblestrip, 6 = special
        ('mFlat', ctypes.c_bool),                                           # whether tire is flat
        ('mDetached', ctypes.c_bool),                                       # whether wheel is detached
        ('mStaticUndeflectedRadius', ctypes.c_ubyte),                        # tire radius in centimeters
        ('mVerticalTireDeflection', ctypes.c_double),                       # how much is tire deflected from its (speed-sensitive) radius
        ('mWheelYLocation', ctypes.c_double),                               # wheel's y location relative to vehicle y location
        ('mToe', ctypes.c_double),                                          # current toe angle w.r.t. the vehicle
        ('mTireCarcassTemperature', ctypes.c_double),                       # rough average of temperature samples from carcass (Kelvin)
        ('mTireInnerLayerTemperature', ctypes.c_double*3),                  # rough average of temperature samples from innermost layer of rubber (before carcass) (Kelvin)
        ('mExpansion', ctypes.c_ubyte*24),                                           # for future use
    ]
#untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2VehicleTelemetry(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mID', ctypes.c_int),                                              # slot ID (note that it can be re-used in multiplayer after someone leaves)
        ('mDeltaTime', ctypes.c_double),                                    # time since last update (seconds)
        ('mElapsedTime', ctypes.c_double),                                  # game session time
        ('mLapNumber', ctypes.c_int),                                       # current lap number
        ('mLapStartET', ctypes.c_double),                                   # time this lap was started
        ('mVehicleName', ctypes.c_char*64),                                  # current vehicle name
        ('mTrackName', ctypes.c_char*64),                                    # current track name
        ('mPos', rF2Vec3),                                         # world position in meters
        ('mLocalVel', rF2Vec3),                                    # velocity (meters/sec) in local vehicle coordinates
        ('mLocalAccel', rF2Vec3),                                  # acceleration (meters/sec^2) in local vehicle coordinates
        ('mOri', rF2Vec3*3),                                       # rows of orientation matrix (use TelemQuat conversions if desired), also converts local
        ('mLocalRot', rF2Vec3),                                    # rotation (radians/sec) in local vehicle coordinates
        ('mLocalRotAccel', rF2Vec3),                               # rotational acceleration (radians/sec^2) in local vehicle coordinates
        ('mGear', ctypes.c_int),                                            # -1=reverse, 0=neutral, 1+ = forward gears
        ('mEngineRPM', ctypes.c_double),                                    # engine RPM
        ('mEngineWaterTemp', ctypes.c_double),                              # Celsius
        ('mEngineOilTemp', ctypes.c_double),                                # Celsius
        ('mClutchRPM', ctypes.c_double),                                    # clutch RPM
        ('mUnfilteredThrottle', ctypes.c_double),                           # ranges  0.0-1.0
        ('mUnfilteredBrake', ctypes.c_double),                              # ranges  0.0-1.0
        ('mUnfilteredSteering', ctypes.c_double),                           # ranges -1.0-1.0 (left to right)
        ('mUnfilteredClutch', ctypes.c_double),                             # ranges  0.0-1.0
        ('mFilteredThrottle', ctypes.c_double),                             # ranges  0.0-1.0
        ('mFilteredBrake', ctypes.c_double),                                # ranges  0.0-1.0
        ('mFilteredSteering', ctypes.c_double),                             # ranges -1.0-1.0 (left to right)
        ('mFilteredClutch', ctypes.c_double),                               # ranges  0.0-1.0
        ('mSteeringShaftTorque', ctypes.c_double),                          # torque around steering shaft (used to be mSteeringArmForce, but that is not necessarily accurate for feedback purposes)
        ('mFront3rdDeflection', ctypes.c_double),                           # deflection at front 3rd spring
        ('mRear3rdDeflection', ctypes.c_double),                            # deflection at rear 3rd spring
        ('mFrontWingHeight', ctypes.c_double),                              # front wing height
        ('mFrontRideHeight', ctypes.c_double),                              # front ride height
        ('mRearRideHeight', ctypes.c_double),                               # rear ride height
        ('mDrag', ctypes.c_double),                                         # drag
        ('mFrontDownforce', ctypes.c_double),                               # front downforce
        ('mRearDownforce', ctypes.c_double),                                # rear downforce
        ('mFuel', ctypes.c_double),                                         # amount of fuel (liters)
        ('mEngineMaxRPM', ctypes.c_double),                                 # rev limit
        ('mScheduledStops', ctypes.c_ubyte),                                 # number of scheduled pitstops
        ('mOverheating', ctypes.c_bool),                                    # whether overheating icon is shown
        ('mDetached', ctypes.c_bool),                                       # whether any parts (besides wheels) have been detached
        ('mHeadlights', ctypes.c_bool),                                     # whether headlights are on
        ('mDentSeverity', ctypes.c_ubyte*8),                                 # dent severity at 8 locations around the car (0=none, 1=some, 2=more)
        ('mLastImpactET', ctypes.c_double),                                 # time of last impact
        ('mLastImpactMagnitude', ctypes.c_double),                          # magnitude of last impact
        ('mLastImpactPos', rF2Vec3),                               # location of last impact
        ('mEngineTorque', ctypes.c_double),                                 # current engine torque (including additive torque) (used to be mEngineTq, but there's little reason to abbreviate it)
        ('mCurrentSector', ctypes.c_int),                                   # the current sector (zero-based) with the pitlane stored in the sign bit (example: entering pits from third sector gives 0x80000002)
        ('mSpeedLimiter', ctypes.c_ubyte),                                   # whether speed limiter is on
        ('mMaxGears', ctypes.c_ubyte),                                       # maximum forward gears
        ('mFrontTireCompoundIndex', ctypes.c_ubyte),                         # index within brand
        ('mRearTireCompoundIndex', ctypes.c_ubyte),                          # index within brand
        ('mFuelCapacity', ctypes.c_double),                                 # capacity in liters
        ('mFrontFlapActivated', ctypes.c_ubyte),                             # whether front flap is activated
        ('mRearFlapActivated', ctypes.c_ubyte),                              # whether rear flap is activated
        ('mRearFlapLegalStatus', ctypes.c_ubyte),                            # 0=disallowed, 1=criteria detected but not allowed quite yet, 2 = allowed
        ('mIgnitionStarter', ctypes.c_ubyte),                                # 0=off 1=ignition 2 = ignition+starter
        ('mFrontTireCompoundName', ctypes.c_char*18),                        # name of front tire compound
        ('mRearTireCompoundName', ctypes.c_char*18),                         # name of rear tire compound
        ('mSpeedLimiterAvailable', ctypes.c_ubyte),                          # whether speed limiter is available
        ('mAntiStallActivated', ctypes.c_ubyte),                             # whether (hard) anti-stall is activated
        ('mUnused', ctypes.c_ubyte*2),                                       #
        ('mVisualSteeringWheelRange', ctypes.c_float),                      # the *visual* steering wheel range
        ('mRearBrakeBias', ctypes.c_double),                                # fraction of brakes on rear
        ('mTurboBoostPressure', ctypes.c_double),                           # current turbo boost pressure if available
        ('mPhysicsToGraphicsOffset', ctypes.c_float*3),                     # offset from static CG to graphical center
        ('mPhysicalSteeringWheelRange', ctypes.c_float),                    # the *physical* steering wheel range
        ('mDeltaBest', ctypes.c_double),                                    # (omitted in error by S397)
        ('mBatteryChargeFraction', ctypes.c_double),                        # Battery charge as fraction [0.0-1.0]
        ('mElectricBoostMotorTorque', ctypes.c_double),                     # current torque of boost motor (can be negative when in regenerating mode)
        ('mElectricBoostMotorRPM', ctypes.c_double),                        # current rpm of boost motor
        ('mElectricBoostMotorTemperature', ctypes.c_double),                # current temperature of boost motor
        ('mElectricBoostWaterTemperature', ctypes.c_double),                # current water temperature of boost motor cooler if present (0 otherwise)
        ('mElectricBoostMotorState', ctypes.c_ubyte),                       # 0=unavailable 1=inactive, 2=propulsion, 3=regeneration
        ('mExpansion', ctypes.c_ubyte*103),                                 # for future use (note that the slot ID has been moved to mID above)
        ('mWheels', rF2Wheel*4),                                   # wheel info (front left, front right, rear left, rear right)
    ]
#untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2ScoringInfo(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mTrackName', ctypes.c_char*64),                                    # current track name
        ('mSession', ctypes.c_int),                                         # current session (0=testday 1-4=practice 5-8=qual 9=warmup 10-13 = race)
        ('mCurrentET', ctypes.c_double),                                    # current time
        ('mEndET', ctypes.c_double),                                        # ending time
        ('mMaxLaps', ctypes.c_int),                                         # maximum laps
        ('mLapDist', ctypes.c_double),                                      # distance around track
        ('pointer1', ctypes.c_ubyte*8),
        ('mNumVehicles', ctypes.c_int),                                     # current number of vehicles
        ('mGamePhase', ctypes.c_ubyte),
        ('mYellowFlagState', ctypes.c_char),
        ('mSectorFlag', ctypes.c_ubyte*3),                                  # whether there are any local yellows at the moment in each sector (not sure if sector 0 is first or last, so test)
        ('mStartLight', ctypes.c_ubyte),                                     # start light frame (number depends on track)
        ('mNumRedLights', ctypes.c_ubyte),                                   # number of red lights in start sequence
        ('mInRealtime', ctypes.c_bool),                                     # in realtime as opposed to at the monitor
        ('mPlayerName', ctypes.c_char*32),                                   # player name (including possible multiplayer override)
        ('mPlrFileName', ctypes.c_char*64),                                  # may be encoded to be a legal filename
        ('mDarkCloud', ctypes.c_double),                                    # cloud darkness? 0.0-1.0
        ('mRaining', ctypes.c_double),                                      # raining severity 0.0-1.0
        ('mAmbientTemp', ctypes.c_double),                                  # temperature (Celsius)
        ('mTrackTemp', ctypes.c_double),                                    # temperature (Celsius)
        ('mWind', rF2Vec3),                                        # wind speed
        ('mMinPathWetness', ctypes.c_double),                               # minimum wetness on main path 0.0-1.0
        ('mMaxPathWetness', ctypes.c_double),                               # maximum wetness on main path 0.0-1.0
        ('mGameMode', ctypes.c_ubyte),                                       # 1 = server, 2 = client, 3 = server and client
        ('mIsPasswordProtected', ctypes.c_bool),                            # is the server password protected
        ('mServerPort', ctypes.c_ushort),                                   # the port of the server (if on a server)
        ('mServerPublicIP', ctypes.c_uint),                                 # the public IP address of the server (if on a server)
        ('mMaxPlayers', ctypes.c_int),                                      # maximum number of vehicles that can be in the session
        ('mServerName', ctypes.c_char*32),                                   # name of the server
        ('mStartET', ctypes.c_float),                                       # start time (seconds since midnight) of the event
        ('mAvgPathWetness', ctypes.c_double),                               # average wetness on main path 0.0-1.0
        ('mExpansion', ctypes.c_ubyte*200),
        ('pointer2', ctypes.c_ubyte*8),
    ]
#untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2VehicleScoring(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mID', ctypes.c_int),                                              # slot ID (note that it can be re-used in multiplayer after someone leaves)
        ('mDriverName', ctypes.c_char*32),                                   # driver name
        ('mVehicleName', ctypes.c_char*64),                                  # vehicle name
        ('mTotalLaps', ctypes.c_short),                                     # laps completed
        ('mSector', ctypes.c_byte),                                        # 0=sector3, 1=sector1, 2 = sector2 (don't ask why)
        ('mFinishStatus', ctypes.c_byte),                                  # 0=none, 1=finished, 2=dnf, 3 = dq
        ('mLapDist', ctypes.c_double),                                      # current distance around track
        ('mPathLateral', ctypes.c_double),                                  # lateral position with respect to *very approximate* "center" path
        ('mTrackEdge', ctypes.c_double),                                    # track edge (w.r.t. "center" path) on same side of track as vehicle
        ('mBestSector1', ctypes.c_double),                                  # best sector 1
        ('mBestSector2', ctypes.c_double),                                  # best sector 2 (plus sector 1)
        ('mBestLapTime', ctypes.c_double),                                  # best lap time
        ('mLastSector1', ctypes.c_double),                                  # last sector 1
        ('mLastSector2', ctypes.c_double),                                  # last sector 2 (plus sector 1)
        ('mLastLapTime', ctypes.c_double),                                  # last lap time
        ('mCurSector1', ctypes.c_double),                                   # current sector 1 if valid
        ('mCurSector2', ctypes.c_double),                                   # current sector 2 (plus sector 1) if valid
        ('mNumPitstops', ctypes.c_short),                                   # number of pitstops made
        ('mNumPenalties', ctypes.c_short),                                  # number of outstanding penalties
        ('mIsPlayer', ctypes.c_bool),                                       # is this the player's vehicle
        ('mControl', ctypes.c_byte),                                       # who's in control: -1=nobody (shouldn't get this), 0=local player, 1=local AI, 2=remote, 3 = replay (shouldn't get this)
        ('mInPits', ctypes.c_bool),                                         # between pit entrance and pit exit (not always accurate for remote vehicles)
        ('mPlace', ctypes.c_ubyte),                                          # 1-based position
        ('mVehicleClass', ctypes.c_char*32),                                 # vehicle class
        ('mTimeBehindNext', ctypes.c_double),                               # time behind vehicle in next higher place
        ('mLapsBehindNext', ctypes.c_int),                                  # laps behind vehicle in next higher place
        ('mTimeBehindLeader', ctypes.c_double),                             # time behind leader
        ('mLapsBehindLeader', ctypes.c_int),                                # laps behind leader
        ('mLapStartET', ctypes.c_double),                                   # time this lap was started
        ('mPos', rF2Vec3),                                         # world position in meters
        ('mLocalVel', rF2Vec3),                                    # velocity (meters/sec) in local vehicle coordinates
        ('mLocalAccel', rF2Vec3),                                  # acceleration (meters/sec^2) in local vehicle coordinates
        ('mOri', rF2Vec3*3),                                       # rows of orientation matrix (use TelemQuat conversions if desired), also converts local
        ('mLocalRot', rF2Vec3),                                    # rotation (radians/sec) in local vehicle coordinates
        ('mLocalRotAccel', rF2Vec3),                               # rotational acceleration (radians/sec^2) in local vehicle coordinates
        ('mHeadlights', ctypes.c_ubyte),                                     # status of headlights
        ('mPitState', ctypes.c_ubyte),                                       # 0=none, 1=request, 2=entering, 3=stopped, 4 = exiting
        ('mServerScored', ctypes.c_ubyte),                                   # whether this vehicle is being scored by server (could be off in qualifying or racing heats)
        ('mIndividualPhase', ctypes.c_ubyte),                                # game phases (described below) plus 9=after formation, 10=under yellow, 11 = under blue (not used)
        ('mQualification', ctypes.c_int),                                   # 1-based, can be -1 when invalid
        ('mTimeIntoLap', ctypes.c_double),                                  # estimated time into lap
        ('mEstimatedLapTime', ctypes.c_double),                             # estimated laptime used for 'time behind' and 'time into lap' (note: this may changed based on vehicle and setup!?)
        ('mPitGroup', ctypes.c_char*24),                                     # pit group (same as team name unless pit is shared)
        ('mFlag', ctypes.c_ubyte),                                           # primary flag being shown to vehicle (currently only 0=green or 6 = blue)
        ('mUnderYellow', ctypes.c_bool),                                    # whether this car has taken a full-course caution flag at the start/finish line
        ('mCountLapFlag', ctypes.c_ubyte),                                   # 0 = do not count lap or time, 1 = count lap but not time, 2 = count lap and time
        ('mInGarageStall', ctypes.c_bool),                                  # appears to be within the correct garage stall
        ('mUpgradePack', ctypes.c_ubyte*16),                                  # Coded upgrades
        ('mPitLapDist', ctypes.c_float),                                    # location of pit in terms of lap distance
        ('mBestLapSector1', ctypes.c_float),                                # sector 1 time from best lap (not necessarily the best sector 1 time)
        ('mBestLapSector2', ctypes.c_float),                                # sector 2 time from best lap (not necessarily the best sector 2 time)
        ('mExpansion', ctypes.c_ubyte*48),                                    # for future use
    ]
#untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2PhysicsOptions(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mTractionControl', ctypes.c_ubyte),                                # 0 (off) - 3 (high)
        ('mAntiLockBrakes', ctypes.c_ubyte),                                 # 0 (off) - 2 (high)
        ('mStabilityControl', ctypes.c_ubyte),                               # 0 (off) - 2 (high)
        ('mAutoShift', ctypes.c_ubyte),                                      # 0 (off), 1 (upshifts), 2 (downshifts), 3 (all)
        ('mAutoClutch', ctypes.c_ubyte),                                     # 0 (off), 1 (on)
        ('mInvulnerable', ctypes.c_ubyte),                                   # 0 (off), 1 (on)
        ('mOppositeLock', ctypes.c_ubyte),                                   # 0 (off), 1 (on)
        ('mSteeringHelp', ctypes.c_ubyte),                                   # 0 (off) - 3 (high)
        ('mBrakingHelp', ctypes.c_ubyte),                                    # 0 (off) - 2 (high)
        ('mSpinRecovery', ctypes.c_ubyte),                                   # 0 (off), 1 (on)
        ('mAutoPit', ctypes.c_ubyte),                                        # 0 (off), 1 (on)
        ('mAutoLift', ctypes.c_ubyte),                                       # 0 (off), 1 (on)
        ('mAutoBlip', ctypes.c_ubyte),                                       # 0 (off), 1 (on)
        ('mFuelMult', ctypes.c_ubyte),                                       # fuel multiplier (0x-7x)
        ('mTireMult', ctypes.c_ubyte),                                       # tire wear multiplier (0x-7x)
        ('mMechFail', ctypes.c_ubyte),                                       # mechanical failure setting; 0 (off), 1 (normal), 2 (timescaled)
        ('mAllowPitcrewPush', ctypes.c_ubyte),                               # 0 (off), 1 (on)
        ('mRepeatShifts', ctypes.c_ubyte),                                   # accidental repeat shift prevention (0-5; see PLR file)
        ('mHoldClutch', ctypes.c_ubyte),                                     # for auto-shifters at start of race: 0 (off), 1 (on)
        ('mAutoReverse', ctypes.c_ubyte),                                    # 0 (off), 1 (on)
        ('mAlternateNeutral', ctypes.c_ubyte),                               # Whether shifting up and down simultaneously equals neutral
        ('mAIControl', ctypes.c_ubyte),                                      # Whether player vehicle is currently under AI control
        ('mUnused1', ctypes.c_ubyte),                                        #
        ('mUnused2', ctypes.c_ubyte),                                        #
        ('mManualShiftOverrideTime', ctypes.c_float),                       # time before auto-shifting can resume after recent manual shift
        ('mAutoShiftOverrideTime', ctypes.c_float),                         # time before manual shifting can resume after recent auto shift
        ('mSpeedSensitiveSteering', ctypes.c_float),                        # 0.0 (off) - 1.0
        ('mSteerRatioSpeed', ctypes.c_float),                               # speed (m/s) under which lock gets expanded to full
    ]
class rF2TrackRulesCommand(Enum):
        AddFromTrack = 0
#untranslated AddFromPit,                   // exited pit during full-course yellow
#untranslated AddFromUndq,                  // during a full-course yellow, the admin reversed a disqualification
#untranslated RemoveToPit,                  // entered pit during full-course yellow
#untranslated RemoveToDnf,                  // vehicle DNF'd during full-course yellow
#untranslated RemoveToDq,                   // vehicle DQ'd during full-course yellow
#untranslated RemoveToUnloaded,             // vehicle unloaded (possibly kicked out or banned) during full-course yellow
#untranslated MoveToBack,                   // misbehavior during full-course yellow, resulting in the penalty of being moved to the back of their current line
#untranslated LongestTime,                  // misbehavior during full-course yellow, resulting in the penalty of being moved to the back of the longest line
#untranslated Maximum                       // should be last
#untranslated [StructLayout(LayoutKind.Sequential, Pack = 4)]
class rF2TrackRulesAction(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mCommand', ctypes.c_int),                        # recommended action
        ('mID', ctypes.c_int),                                              # slot ID if applicable
        ('mET', ctypes.c_double),                                           # elapsed time that event occurred, if applicable
    ]
class rF2TrackRulesColumn(Enum):
        LeftLane = 0
        MidLefLane = 1                    # mid-left
        MiddleLane = 2                    # middle
        MidrRghtLane = 3                  # mid-right
        RightLane = 4                     # right (outside)
        MaxLanes = 5                      # should be after the valid static lane choices
        Invalid = MaxLanes
        FreeChoice = 6                    # free choice (dynamically chosen by driver)
        Pending = 7                       # depends on another participant's free choice (dynamically set after another driver chooses)
        Maximum = 8                       # should be last
#untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2TrackRulesParticipant(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mID', ctypes.c_int),                                              # slot ID
        ('mFrozenOrder', ctypes.c_short),                                   # 0-based place when caution came out (not valid for formation laps)
        ('mPlace', ctypes.c_short),                                         # 1-based place (typically used for the initialization of the formation lap track order)
        ('mYellowSeverity', ctypes.c_float),                                # a rating of how much this vehicle is contributing to a yellow flag (the sum of all vehicles is compared to TrackRulesV01::mSafetyCarThreshold)
        ('mCurrentRelativeDistance', ctypes.c_double),                      # equal to ( ( ScoringInfoV01::mLapDist * this->mRelativeLaps ) + VehicleScoringInfoV01::mLapDist )
        ('mRelativeLaps', ctypes.c_int),                                    # current formation/caution laps relative to safety car (should generally be zero except when safety car crosses s/f line); this can be decremented to implement 'wave around' or 'beneficiary rule' (a.k.a. 'lucky dog' or 'free pass')
        ('mColumnAssignment', ctypes.c_int),                # which column (line/lane) that participant is supposed to be in
        ('mPositionAssignment', ctypes.c_int),                              # 0-based position within column (line/lane) that participant is supposed to be located at (-1 is invalid)
        ('mPitsOpen', ctypes.c_ubyte),                                      # whether the rules allow this particular vehicle to enter pits right now (input is 2=false or 3=true; if you want to edit it, set to 0=false or 1 = true)
        ('mUpToSpeed', ctypes.c_bool),                                      # while in the frozen order, this flag indicates whether the vehicle can be followed (this should be false for somebody who has temporarily spun and hasn't gotten back up to speed yet)
        ('mUnused', ctypes.c_bool*2),                                       #
        ('mGoalRelativeDistance', ctypes.c_double),                         # calculated based on where the leader is, and adjusted by the desired column spacing and the column/position assignments
        ('mMessage', ctypes.c_char*96),                                     # a message for this participant to explain what is going on it will get run through translator on client machines
        ('mExpansion', ctypes.c_ubyte*192),
    ]
class rF2TrackRulesStage(Enum):
        FormationInit = 0
        FormationUpdate = 1          # update of the formation lap
        Normal = 2                   # normal (non-yellow) update
        CautionInit = 3              # initialization of a full-course yellow
        CautionUpdate = 4            # update of a full-course yellow
        Maximum = 5                  # should be last
#untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2TrackRules(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mCurrentET', ctypes.c_double),                                    # current time
        ('mStage', ctypes.c_int),                            # current stage
        ('mPoleColumn', ctypes.c_int),                      # column assignment where pole position seems to be located
        ('mNumActions', ctypes.c_int),                                      # number of recent actions
        ('pointer1', ctypes.c_ubyte*8),
        ('mNumParticipants', ctypes.c_int),                                 # number of participants (vehicles)
        ('mYellowFlagDetected', ctypes.c_bool),                             # whether yellow flag was requested or sum of participant mYellowSeverity's exceeds mSafetyCarThreshold
        ('mYellowFlagLapsWasOverridden', ctypes.c_ubyte),                    # whether mYellowFlagLaps (below) is an admin request (0=no 1=yes 2 = clear yellow)
        ('mSafetyCarExists', ctypes.c_bool),                                # whether safety car even exists
        ('mSafetyCarActive', ctypes.c_bool),                                # whether safety car is active
        ('mSafetyCarLaps', ctypes.c_int),                                   # number of laps
        ('mSafetyCarThreshold', ctypes.c_float),                            # the threshold at which a safety car is called out (compared to the sum of TrackRulesParticipantV01::mYellowSeverity for each vehicle)
        ('mSafetyCarLapDist', ctypes.c_double),                             # safety car lap distance
        ('mSafetyCarLapDistAtStart', ctypes.c_float),                       # where the safety car starts from
        ('mPitLaneStartDist', ctypes.c_float),                              # where the waypoint branch to the pits breaks off (this may not be perfectly accurate)
        ('mTeleportLapDist', ctypes.c_float),                               # the front of the teleport locations (a useful first guess as to where to throw the green flag)
        ('mInputExpansion', ctypes.c_ubyte*256),
        ('mYellowFlagState', ctypes.c_byte),                               # see ScoringInfoV01 for values
        ('mYellowFlagLaps', ctypes.c_short),                                # suggested number of laps to run under yellow (may be passed in with admin command)
        ('mSafetyCarInstruction', ctypes.c_int),                            # 0=no change, 1=go active, 2 = head for pits
        ('mSafetyCarSpeed', ctypes.c_float),                                # maximum speed at which to drive
        ('mSafetyCarMinimumSpacing', ctypes.c_float),                       # minimum spacing behind safety car (-1 to indicate no limit)
        ('mSafetyCarMaximumSpacing', ctypes.c_float),                       # maximum spacing behind safety car (-1 to indicate no limit)
        ('mMinimumColumnSpacing', ctypes.c_float),                          # minimum desired spacing between vehicles in a column (-1 to indicate indeterminate/unenforced)
        ('mMaximumColumnSpacing', ctypes.c_float),                          # maximum desired spacing between vehicles in a column (-1 to indicate indeterminate/unenforced)
        ('mMinimumSpeed', ctypes.c_float),                                  # minimum speed that anybody should be driving (-1 to indicate no limit)
        ('mMaximumSpeed', ctypes.c_float),                                  # maximum speed that anybody should be driving (-1 to indicate no limit)
        ('mMessage', ctypes.c_char*96),                                      # a message for everybody to explain what is going on (which will get run through translator on client machines)
        ('pointer2', ctypes.c_ubyte*8),
        ('mInputOutputExpansion', ctypes.c_ubyte*256),
    ]
#untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2PitMenu(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mCategoryIndex', ctypes.c_int),                                   # index of the current category
        ('mCategoryName', ctypes.c_char*32),                                 # name of the current category (untranslated)
        ('mChoiceIndex', ctypes.c_int),                                     # index of the current choice (within the current category)
        ('mChoiceString', ctypes.c_char*32),                                 # name of the current choice (may have some translated words)
        ('mNumChoices', ctypes.c_int),                                      # total number of choices (0 < = mChoiceIndex < mNumChoices)
        ('mExpansion', ctypes.c_ubyte*256),                                    # for future use
    ]
#untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2WeatherControlInfo(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mET', ctypes.c_double),                                           # when you want this weather to take effect
        ('mRaining', ctypes.c_double*9),                                    # rain (0.0-1.0) at different nodes
        ('mCloudiness', ctypes.c_double),                                   # general cloudiness (0.0=clear to 1.0 = dark)
        ('mAmbientTempK', ctypes.c_double),                                 # ambient temperature (Kelvin)
        ('mWindMaxSpeed', ctypes.c_double),                                 # maximum speed of wind (ground speed, but it affects how fast the clouds move, too)
        ('mApplyCloudinessInstantly', ctypes.c_bool),                       # preferably we roll the new clouds in, but you can instantly change them now
        ('mUnused1', ctypes.c_bool),                                        #
        ('mUnused2', ctypes.c_bool),                                        #
        ('mUnused3', ctypes.c_bool),                                        #
        ('mExpansion', ctypes.c_ubyte*508),                                    # future use (humidity, pressure, air density, etc.)
    ]
#untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2MappedBufferVersionBlock(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mVersionUpdateBegin', ctypes.c_uint),                             # Incremented right before buffer is written to.
        ('mVersionUpdateEnd', ctypes.c_uint),                               # Incremented after buffer write is done.
    ]
#untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2MappedBufferVersionBlockWithSize(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mVersionUpdateBegin', ctypes.c_uint),                             # Incremented right before buffer is written to.
        ('mVersionUpdateEnd', ctypes.c_uint),                               # Incremented after buffer write is done.
        ('mBytesUpdatedHint', ctypes.c_int),                                # How many bytes of the structure were written during the last update.
    ]
#untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2Telemetry(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mVersionUpdateBegin', ctypes.c_uint),                             # Incremented right before buffer is written to.
        ('mVersionUpdateEnd', ctypes.c_uint),                               # Incremented after buffer write is done.
        ('mBytesUpdatedHint', ctypes.c_int),                                # How many bytes of the structure were written during the last update.
        ('mNumVehicles', ctypes.c_int),                                     # current number of vehicles
        ('mVehicles', rF2VehicleTelemetry*rFactor2Constants.MAX_MAPPED_VEHICLES),
    ]
#untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2Scoring(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mVersionUpdateBegin', ctypes.c_uint),                             # Incremented right before buffer is written to.
        ('mVersionUpdateEnd', ctypes.c_uint),                               # Incremented after buffer write is done.
        ('mBytesUpdatedHint', ctypes.c_int),                                # How many bytes of the structure were written during the last update.
        ('mScoringInfo', rF2ScoringInfo),
        ('mVehicles', rF2VehicleScoring*rFactor2Constants.MAX_MAPPED_VEHICLES),
    ]
#untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2Rules(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mVersionUpdateBegin', ctypes.c_uint),                             # Incremented right before buffer is written to.
        ('mVersionUpdateEnd', ctypes.c_uint),                               # Incremented after buffer write is done.
        ('mBytesUpdatedHint', ctypes.c_int),                                # How many bytes of the structure were written during the last update.
        ('mTrackRules', rF2TrackRules),
        ('mActions', rF2TrackRulesAction*rFactor2Constants.MAX_MAPPED_VEHICLES),
        ('mParticipants', rF2TrackRulesParticipant*rFactor2Constants.MAX_MAPPED_VEHICLES),
    ]
#untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2ForceFeedback(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mVersionUpdateBegin', ctypes.c_uint),                             # Incremented right before buffer is written to.
        ('mVersionUpdateEnd', ctypes.c_uint),                               # Incremented after buffer write is done.
        ('mForceValue', ctypes.c_double),                                   # Current FFB value reported via InternalsPlugin::ForceFeedback.
    ]
#untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2GraphicsInfo(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mCamPos', rF2Vec3),                                      # camera position
        ('mCamOri', rF2Vec3*3),                                    # rows of orientation matrix (use TelemQuat conversions if desired), also converts local
        ('mHWND', ctypes.c_ubyte*8),                                         # app handle
        ('mAmbientRed', ctypes.c_double),
        ('mAmbientGreen', ctypes.c_double),
        ('mAmbientBlue', ctypes.c_double),
        ('mID', ctypes.c_int),                                              # slot ID being viewed (-1 if invalid)
        ('mCameraType', ctypes.c_int),                                      # see above comments for possible values
        ('mExpansion', ctypes.c_ubyte*128),                                    # for future use (possibly camera name)
    ]
#untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2Graphics(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mVersionUpdateBegin', ctypes.c_uint),                             # Incremented right before buffer is written to.
        ('mVersionUpdateEnd', ctypes.c_uint),                               # Incremented after buffer write is done.
        ('mGraphicsInfo', rF2GraphicsInfo),
    ]
#untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2PitInfo(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mVersionUpdateBegin', ctypes.c_uint),                             # Incremented right before buffer is written to.
        ('mVersionUpdateEnd', ctypes.c_uint),                               # Incremented after buffer write is done.
        ('mPitMneu', rF2PitMenu),
    ]
#untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2Weather(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mVersionUpdateBegin', ctypes.c_uint),                             # Incremented right before buffer is written to.
        ('mVersionUpdateEnd', ctypes.c_uint),                               # Incremented after buffer write is done.
        ('mTrackNodeSize', ctypes.c_double),
        ('mWeatherInfo', rF2WeatherControlInfo),
    ]
#untranslated [StructLayout(LayoutKind.Sequential, Pack = 4)]
class rF2TrackedDamage(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mMaxImpactMagnitude', ctypes.c_double),                           # Max impact magnitude.  Tracked on every telemetry update, and reset on visit to pits or Session restart.
        ('mAccumulatedImpactMagnitude', ctypes.c_double),                   # Accumulated impact magnitude.  Tracked on every telemetry update, and reset on visit to pits or Session restart.
    ]
#untranslated [StructLayout(LayoutKind.Sequential, Pack = 4)]
class rF2VehScoringCapture(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mID', ctypes.c_int),                                              # slot ID (note that it can be re-used in multiplayer after someone leaves)
        ('mPlace', ctypes.c_ubyte),
        ('mIsPlayer', ctypes.c_bool),
        ('mFinishStatus', ctypes.c_byte),                                  # 0=none, 1=finished, 2=dnf, 3 = dq
    ]
#untranslated [StructLayout(LayoutKind.Sequential, Pack = 4)]
class rF2SessionTransitionCapture(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mGamePhase', ctypes.c_ubyte),
        ('mSession', ctypes.c_int),
        ('mNumScoringVehicles', ctypes.c_int),
        ('mScoringVehicles', rF2VehScoringCapture*rFactor2Constants.MAX_MAPPED_VEHICLES),
    ]
#untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2Extended(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mVersionUpdateBegin', ctypes.c_uint),                             # Incremented right before buffer is written to.
        ('mVersionUpdateEnd', ctypes.c_uint),                               # Incremented after buffer write is done.
        ('mVersion', ctypes.c_char*12),                                      # API version
        ('is64bit', ctypes.c_bool),                                         # Is 64bit plugin?
        ('mPhysics', rF2PhysicsOptions),
        ('mTrackedDamages', rF2TrackedDamage*rFactor2Constants.MAX_MAPPED_IDS),
        ('mInRealtimeFC', ctypes.c_bool),                                   # in realtime as opposed to at the monitor (reported via last EnterRealtime/ExitRealtime calls).
        ('mMultimediaThreadStarted', ctypes.c_bool),                        # multimedia thread started (reported via ThreadStarted/ThreadStopped calls).
        ('mSimulationThreadStarted', ctypes.c_bool),                        # simulation thread started (reported via ThreadStarted/ThreadStopped calls).
        ('mSessionStarted', ctypes.c_bool),                                 # Set to true on Session Started, set to false on Session Ended.
        ('mTicksSessionStarted', ctypes.c_ulonglong),                           # Ticks when session started.
        ('mTicksSessionEnded', ctypes.c_ulonglong),                             # Ticks when session ended.
        ('mSessionTransitionCapture', rF2SessionTransitionCapture),# Contains partial internals capture at session transition time.
        ('mDisplayedMessageUpdateCapture', ctypes.c_char*128),
        ('mDirectMemoryAccessEnabled', ctypes.c_bool),
        ('mTicksStatusMessageUpdated', ctypes.c_ulonglong),                    # Ticks when status message was updated;
        ('mStatusMessage', ctypes.c_char*rFactor2Constants.MAX_STATUS_MSG_LEN),
        ('mTicksLastHistoryMessageUpdated', ctypes.c_ulonglong),                # Ticks when last message history message was updated;
        ('mLastHistoryMessage', ctypes.c_char*rFactor2Constants.MAX_STATUS_MSG_LEN),
        ('mCurrentPitSpeedLimit', ctypes.c_float),                          # speed limit m/s.
        ('mSCRPluginEnabled', ctypes.c_bool),                               # Is Stock Car Rules plugin enabled?
        ('mSCRPluginDoubleFileType', ctypes.c_int),                         # Stock Car Rules plugin DoubleFileType value, only meaningful if mSCRPluginEnabled is true.
        ('mTicksLSIPhaseMessageUpdated', ctypes.c_ulonglong),                   # Ticks when last LSI phase message was updated.
        ('mLSIPhaseMessage', ctypes.c_char*rFactor2Constants.MAX_RULES_INSTRUCTION_MSG_LEN),
        ('mTicksLSIPitStateMessageUpdated', ctypes.c_ulonglong),                # Ticks when last LSI pit state message was updated.
        ('mLSIPitStateMessage', ctypes.c_char*rFactor2Constants.MAX_RULES_INSTRUCTION_MSG_LEN),
        ('mTicksLSIOrderInstructionMessageUpdated', ctypes.c_ulonglong),        # Ticks when last LSI order instruction message was updated.
        ('mLSIOrderInstructionMessage', ctypes.c_char*rFactor2Constants.MAX_RULES_INSTRUCTION_MSG_LEN),
        ('mTicksLSIRulesInstructionMessageUpdated', ctypes.c_ulonglong),        # Ticks when last FCY rules message was updated.  Currently, only SCR plugin sets that.
        ('mLSIRulesInstructionMessage', ctypes.c_char*rFactor2Constants.MAX_RULES_INSTRUCTION_MSG_LEN),
        ('mUnsubscribedBuffersMask', ctypes.c_int),                         # Currently active UnsbscribedBuffersMask value.  This will be allowed for clients to write to in the future, but not yet.
        ('mHWControlInputEnabled', ctypes.c_bool),                          # HWControl input buffer is enabled.
        ('mWeatherControlInputEnabled', ctypes.c_bool),                     # WeatherControl input buffer is enabled.
        ('mRulesControlInputEnabled', ctypes.c_bool),                       # RulesControl input buffer is enabled.
    ]
#untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2HWControl(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mVersionUpdateBegin', ctypes.c_uint),                             # Incremented right before buffer is written to.
        ('mVersionUpdateEnd', ctypes.c_uint),                               # Incremented after buffer write is done.
        ('mLayoutVersion', ctypes.c_int),
        ('mControlName', ctypes.c_char*rFactor2Constants.MAX_HWCONTROL_NAME_LEN),
        ('mfRetVal', ctypes.c_double),
    ]
#untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2WeatherControl(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('mVersionUpdateBegin', ctypes.c_uint),                             # Incremented right before buffer is written to.
        ('mVersionUpdateEnd', ctypes.c_uint),                               # Incremented after buffer write is done.
        ('mLayoutVersion', ctypes.c_int),
        ('mWeatherInfo', rF2WeatherControlInfo),
    ]
class SubscribedBuffer(Enum):
        Telemetry = 1,
        Scoring = 2,
        Rules = 4,
        MultiRules = 8,
        ForceFeedback = 16,
        Graphics = 32,
        PitInfo = 64,
        Weather = 128,
        All = 255

class SimInfo:
    def __init__(self):
        self._rf2_tele = mmap.mmap(0, ctypes.sizeof(rF2Telemetry), "$rFactor2SMMP_Telemetry$")
        self.Rf2Tele = rF2Telemetry.from_buffer(self._rf2_tele)
        self._rf2_scor = mmap.mmap(0, ctypes.sizeof(rF2Scoring), "$rFactor2SMMP_Scoring$")
        self.Rf2Scor = rF2Scoring.from_buffer(self._rf2_scor)
        self._rf2_ext = mmap.mmap(0, ctypes.sizeof(rF2Extended), "$rFactor2SMMP_Extended$")
        self.Rf2Ext = rF2Extended.from_buffer(self._rf2_ext)
        self._rf2_ffb = mmap.mmap(0, ctypes.sizeof(rF2ForceFeedback), "$rFactor2SMMP_ForceFeedback$")
        self.Rf2Ffb = rF2ForceFeedback.from_buffer(self._rf2_ffb)
    def close(self):
      # This didn't help with the errors
      try:
        self._rf2_tele.close()
        self._rf2_scor.close()
        self._rf2_ext.close()
        self._rf2_ffb.close()
      except BufferError: # "cannot close exported pointers exist"
        pass

    def __del__(self):
        self.close()

def check_rf2_lmu():
    global ffbReport
    global connectedGame
    if connectedGame == RunningGame.NONE or connectedGame == RunningGame.RF2_LMU:
        info = SimInfo()
        if info.Rf2Ext.mInRealtimeFC is True:
            vnmDataReport = converByteArrayToVnmDataReport(struct.unpack(vnm_data_format_string, Datas.Value["VNM_DATA_REPORT"]))
            connectedGame = RunningGame.RF2_LMU
            ffbReport.vnmSteeringAngle = round(info.Rf2Tele.mVehicles[0].mFilteredSteering*10000)
            ffbReport.vnmFinalFFB =  -round(info.Rf2Ffb.mForceValue*10000)
            ffbReport.vnmThrottle =  round(info.Rf2Tele.mVehicles[0].mFilteredThrottle*10000)
            ffbReport.vnmBrake =  round(info.Rf2Tele.mVehicles[0].mFilteredBrake*10000)
            ffbReport.vnmClutch = round(info.Rf2Tele.mVehicles[0].mFilteredClutch*10000)
            ffbReport.vnmGear = round(info.Rf2Tele.mVehicles[0].mGear)
            ffbReport.vnmRpm = round(info.Rf2Tele.mVehicles[0].mEngineRPM)
            ffbReport.vnmSpeedKmh = round(math.hypot(info.Rf2Tele.mVehicles[0].mLocalVel.x, info.Rf2Tele.mVehicles[0].mLocalVel.y, info.Rf2Tele.mVehicles[0].mLocalVel.z)*3.6)
            ffbReport.vnmFuel = round(info.Rf2Tele.mVehicles[0].mFuel)
            road_texture = (info.Rf2Tele.mVehicles[0].mWheels[1].mSuspensionDeflection*500000 - vnmDataReport.suspensionRight - info.Rf2Tele.mVehicles[0].mWheels[0].mSuspensionDeflection*500000 + vnmDataReport.suspensionLeft) * pluginConfig["RoadTextureGain"]/100
            if road_texture == 0:
                road_texture = vnmDataReport.rf2LmuOldroadTexture
            vnmDataReport.rf2LmuOldroadTexture = road_texture
            vnmDataReport.suspensionLeft = info.Rf2Tele.mVehicles[0].mWheels[0].mSuspensionDeflection*500000
            vnmDataReport.suspensionRight = info.Rf2Tele.mVehicles[0].mWheels[1].mSuspensionDeflection*500000
            ffbReport.vnmFinalFFB += clamp(round(road_texture), -3000, 3000)
            Datas.Value["VNM_DATA_REPORT"] = vnmDataReport.to_bytes()
        else:
            connectedGame = RunningGame.NONE


################################################################################# R3E #########################################################################################################
#https://github.com/dzosz/OpenRacingHUD

'''
class r3e_vec3_f64(Structure):
    _pack_ = 1
    _fields_ = [("x", c_double),
                ("y", c_double),
                ("z", c_double)
                ]
'''

class r3e_playerdata(Structure):
    _pack_ = 1
    _fields_ = [("game_simulation_ticks", c_int),
                ("game_simulation_time", c_double),
                ("position", c_double * 3),
                ("velocity", c_double * 3),
                ("local_velocity", c_double * 3),
                ("acceleration", c_double * 3),
                ("local_acceleration", c_double * 3),
                ("orientation", c_double * 3),
                ("rotation", c_double * 3),
                ("angular_acceleration", c_double * 3),
                ("angular_velocity", c_double * 3),
                ("local_angular_velocity", c_double * 3),
                ("local_g_force", c_double * 3),
                ("steering_force", c_double),
                ("steering_force_percentage", c_double),
                ("engine_torque", c_double),
                ("current_downforce", c_double),
                ("voltage", c_double),
                ("ers_level", c_double),
                ("power_mgu_h", c_double),
                ("power_mgu_k", c_double),
                ("torque_mgu_k", c_double),
                # Car setup (radians, meters, meters per second)
                ("suspension_deflection", c_double * 4),
                ("suspension_velocity", c_double * 4),
                ("camber", c_double * 4),
                ("ride_height", c_double * 4),
                ("front_wing_height", c_double),
                ("front_roll_angle", c_double),
                ("rear_roll_angle", c_double),
                ("unused1", c_double),
                ("unused2", c_double),
                ("unused3", c_double * 3)
                ]

class r3e_flags(Structure):
    _pack_ = 1
    _fields_ = [("yellow ", c_int),
                ("yellowCausedIt", c_int),
                ("yellowOvertake", c_int),
                ("yellowPositionsGained", c_int),
                ("sector_yellow", c_int * 3),
                ("closest_yellow_distance_into_track", c_float),
                ("blue", c_int),
                ("black", c_int),
                ("green", c_int),
                ("checkered", c_int),
                ("white", c_int),
                ("black_and_white", c_int)
                ]

class r3e_cut_track_penalties(Structure):
    _pack_ = 1
    _fields_ = [("drive_through", c_int),
                ("stop_and_go", c_int),
                ("pit_stop", c_int),
                ("time_deduction", c_int),
                ("slow_down", c_int),
                ]

class r3e_aid_settings(Structure):
    _pack_ = 1
    _fields_ = [("abs", c_int),
                ("tc", c_int),
                ("esp", c_int),
                ("countersteer", c_int),
                ("cornering", c_int),
                ]


class r3e_push_to_pass(Structure):
    _pack_ = 1
    _fields_ = [("available", c_int),
                ("engaged", c_int),
                ("amount_left", c_int),
                ("engaged_time_left", c_int),
                ("wait_time_left", c_int),
                ]

class r3e_drs(Structure):
    _pack_ = 1
    _fields_ = [("equipped", c_int),
                ("available", c_int),
                ("numActivationsLeft", c_int),
                ("engaged", c_int),
                ]


class r3e_brake_temp(Structure):
    _pack_ = 1
    _fields_ = [("current_temp", c_float),
                ("optimal_temp", c_float),
                ("cold_temp", c_float),
                ("hot_temp", c_float),
                ]

class r3e_car_damage(Structure):
    _pack_ = 1
    _fields_ = [("engine", c_float),
                ("transmission", c_float),
                ("aerodynamics", c_float),
                ("suspension", c_float),
                ("unused1", c_float),
                ("unused2", c_float),
                ]

class r3e_tire_temp(Structure):
    _pack_ = 1
    _fields_ = [("current_temp", c_float*3),
                ("optimal_temp", c_float),
                ("cold_temp", c_float),
                ("hot_temp", c_float),
                ]

class r3e_driver_info(Structure):
    _pack_ = 1
    _fields_ = [("car_name", c_char*64),
                ("car_number", c_int),
                ("class_id", c_int),
                ("model_id", c_int),
                ("team_id", c_int),
                ("livery_id", c_int),
                ("manufacturer_id", c_int),
                ("user_id", c_int),
                ("slot_id", c_int),
                ("class_performance_index", c_int),
                ("engine_type", c_int),
                ("unused1", c_int),
                ("unused2", c_int),

                ]

class r3e_shared(Structure):
    _pack_ = 1
    _fields_ = [("version_major", c_int),
                ("version_minor", c_int),
                ("all_drivers_offset", c_int),
                ("drivers_data_size", c_int),
                ("game_paused", c_int),
                ("game_in_menus", c_int),
                ("game_in_replay", c_int),
                ("game_using_vr", c_int),
                ("game_unused1", c_int),
                ("player", r3e_playerdata),
                ("track_name", c_char*64),
                ("layout_name", c_char*64),
                ("track_id", c_int),
                ("layout_id", c_int),
                ("layout_length", c_float),
                ("sector_start_factors", c_float * 3),
                ("race_session_laps", c_int * 3),
                ("race_session_minutes", c_int * 3),
                ("event_index", c_int),
                ("session_type", c_int),
                ("session_iteration", c_int),
                ("session_length_format", c_int),
                ("session_pit_speed_limit", c_float),
                ("session_phase", c_int),
                ("start_lights", c_int),
                ("tire_wear_active", c_int),
                ("fuel_use_active", c_int),
                ("number_of_laps", c_int),
                ("session_time_duration", c_float),
                ("session_time_remaining", c_float),
                ("event_unused1", c_int),
                ("event_unused2", c_float),
                # pit
                ("pit_window_status", c_int),
                ("pit_window_start", c_int),
                ("pit_window_end", c_int),
                ("in_pitlane", c_int),
                ("pit_menu_selection", c_int),
                ("pit_menu_state", c_int * 11),
                ("pit_state", c_int),
                ("pit_total_duration", c_float),
                ("pit_elapsed_time", c_float),
                ("pit_action", c_int),
                ("num_pitstops", c_int),
                ("pit_unused1", c_int),
                ("pit_unused2", c_float),
                ("flags", r3e_flags),
                # scoring and timings
                ("position", c_int ),
                ("position_class", c_int),
                ("finish_status", c_int),
                ("cut_track_warnings", c_int),
                ("penalties", r3e_cut_track_penalties),
                ("num_penalties", c_int),
                ("completed_laps", c_int),
                ("current_lap_valid", c_int),
                ("track_sector", c_int),
                ("lap_distance", c_float),
                ("lap_distance_fraction", c_float),
                ("lap_time_best_leader", c_float),
                ("lap_time_best_leader_class", c_float ),
                ("session_best_lap_sector_times", c_float*3),
                ("lap_time_best_self", c_float),
                ("sector_time_best_self", c_float * 3),
                ("lap_time_previous_self", c_float),
                ("sector_time_previous_self", c_float*3),
                ("lap_time_current_self", c_float),
                ("sector_time_current_self", c_float*3),
                ("lap_time_delta_leader", c_float),
                ("lap_time_delta_leader_class", c_float),
                ("time_delta_front", c_float),
                ("time_delta_behind", c_float),
                ("time_delta_best_self", c_float),
                ("best_individual_sector_time_self", c_float*3),
                ("best_individual_sector_time_leader", c_float*3),
                ("best_individual_sector_time_leader_class", c_float*3),
                ("score_unused1", c_int),
                ("score_unused2", c_int),
                ("score_unused3", c_float),
                ("score_unused4", c_float),
                # vehicle information
                ("vehicle_info", r3e_driver_info),
                ("player_name", c_char*64),
                # vehicle state
                ("control_type", c_int),
                ("speed", c_float),
                ("engine_rps", c_float),
                ("max_engine_rps", c_float),
                ("upshift_rps", c_float),
                ("gear", c_int),
                ("num_gears", c_int),
                ("car_cg_location", c_float * 3),
                ("car_orientation", c_float * 3),
                ("local_acceleration", c_float * 3),
                ("total_mass", c_float),
                ("fuel_left", c_float),
                ("fuel_capacity", c_float),
                ("fuel_per_lap", c_float),
                ("engine_water_temp", c_float),
                ("engine_oil_temp", c_float),
                ("fuel_pressure", c_float),
                ("engine_oil_pressure", c_float),
                ("turbo_pressure", c_float),
                ("throttle", c_float),
                ("throttle_raw", c_float),
                ("brake", c_float),
                ("brake_raw", c_float),
                ("clutch", c_float),
                ("cluch_raw", c_float),
                ("steer_input_raw", c_float),
                ("steer_lock_degrees", c_int),
                ("steer_wheel_range_degrees", c_int),
                ("aid_settings", r3e_aid_settings),
                ("drs", r3e_drs),
                ("pit_limiter", c_int),
                ("push_to_pass", r3e_push_to_pass),
                ("brake_bias", c_float),
                ("vehicle_unused1", c_int),
                ("vehicle_unused2", c_int),
                ("vehicle_unused3", c_float),
                ("vehicle_unused4", c_float),
                ("vehicle_unused5", c_float*3),
                # tires
                ("tire_type", c_int),
                ("tire_rps", c_float * 4),
                ("tire_speed", c_float * 4),
                ("tire_grip", c_float * 4),
                ("tire_wear", c_float * 4),
                ("tire_flatspot", c_int * 4),
                ("tire_pressure", c_float * 4),
                ("tire_dirt", c_float * 4),
                ("tire_temp", r3e_tire_temp * 4),
                ("tire_type_front", c_int),
                ("tire_type_rear", c_int),
                ("tire_subtype_front", c_int),
                ("tire_subtype_rear", c_int),
                ("brake_temp", r3e_brake_temp * 4),
                ("brake_pressure", c_float * 4),
                ("tire_unused1", c_int),
                ("tire_unused2", c_int),
                ("tire_unused3", c_float),
                ("tire_unused4", c_float),
                ("tire_unused5", c_float * 4),
                ("tire_load", c_float * 4),
                ("car_damage", r3e_car_damage),
                ("num_cars", c_int),
                #("all_drivers_data_1 ", r3e_driver_data * 128),
                ]


class RaceRoomData(object):
    def __init__(self):
        self.buff = None

    def getJsonData(self):
        return json.dumps(self.getData())

    def getData(self):
        self.buff.seek(0)
        raw = array('b', self.buff.read(sizeof(r3e_shared)))
        obj = r3e_shared.from_buffer(raw) # IronPython compatibility - needs array type
        return obj

    def start(self):
        if not self.buff:
            R3E_SHARED_MEMORY_NAME = "$R3E"
           # print (sizeof(r3e_shared))
           # print ('RaceRoomData::start() reading shared memory:', R3E_SHARED_MEMORY_NAME)
            self.buff = mmap.mmap(-1, sizeof(r3e_shared), R3E_SHARED_MEMORY_NAME, access=mmap.ACCESS_READ)

    def stop(self):
        if self.buff:
            self.buff.close()
        self.buff = None

    def _getDictFromStructure(self, data, name, obj):
        if isinstance(obj, Structure):
            for fname, ftype in obj._fields_:
                self._getDictFromStructure(data, fname, getattr(obj, fname))
        elif isinstance(obj, Array):
            data[name] = [self._getDictFromStructure({}, "", x) for x in obj]
        elif name:
            data[name] = obj
        else:
            return obj
        return data

    def _convertData(self, data):
        data['wheelSlip'] = [int((1-x)*100) for x in data['tire_grip']]

def check_raceroom():
    global connectedGame
    global ffbReport
    if connectedGame == RunningGame.NONE or connectedGame == RunningGame.RR:
        connectedGame = RunningGame.RR
        r3reader = RaceRoomData()
        r3reader.start()
        r3eTel = r3reader.getData()
        if r3eTel.player.game_simulation_ticks > 0:
            if not r3eTel.game_paused and  not r3eTel.game_in_menus:
                connectedGame = RunningGame.RR
                ffbReport.vnmSteeringAngle = round(r3eTel.steer_input_raw*10000)
                ffbReport.vnmFinalFFB = round(r3eTel.player.steering_force_percentage*10000)
                ffbReport.vnmThrottle = round(r3eTel.throttle_raw*10000)
                ffbReport.vnmBrake = round(r3eTel.brake_raw*10000)
                ffbReport.vnmClutch = round(r3eTel.cluch_raw*10000)
                ffbReport.vnmGear = round(r3eTel.gear)
                ffbReport.vnmRpm = round(r3eTel.engine_rps*60)
                ffbReport.vnmSpeedKmh = round(r3eTel.speed*3.6)
                ffbReport.vnmFuel = round(r3eTel.fuel_left)
                #ffbReport.VnmTCinAction = round(ir['SteeringWheelPctTorqueSign'])
                #ffbReport.VnmABSinAction = round(ir['SteeringWheelPctTorqueSign'])
                #ffbReport.vnmTurboBoost = round(ir['SteeringWheelPctTorqueSign'])
                #ffbReport.vnmPitLimiterOn = ir['SteeringWheelPctTorqueSign']
                #ffbReport.vnmIgnitionOn = ir['SteeringWheelPctTorqueSign']
                #ffbReport.vnmStarterEngineOn = ir['SteeringWheelPctTorqueSign']
                #ffbReport.vnmIsEngineRunning = ir['SteeringWheelPctTorqueSign']
                #ffbReport.vnmKerbVibration = round(ir['SteeringWheelPctTorqueSign'])
                #ffbReport.vnmSlipVibrations = round(ir['SteeringWheelPctTorqueSign'])
                #ffbReport.vnmGVibrations = round(ir['SteeringWheelPctTorqueSign'])
                #ffbReport.vnmAbsVibrations = round(ir['SteeringWheelPctTorqueSign'])
                ffbReport.vnmRpmMax = round(r3eTel.max_engine_rps*60)
                ffbReport.vnmFuelMax = round(r3eTel.fuel_capacity)
                ffbReport.vnmTC = round(r3eTel.aid_settings.tc)
                #ffbReport.vnmTCCut = data.TCCut
                ffbReport.vnmABS = round(r3eTel.aid_settings.abs)
                #ffbReport.VnmEngineMap = data.EngineMap
                #ffbReport.vnmFuelXLap = round(data.fuelXLap*100)
                #ffbReport.vnmFuelEstimatedLaps = round(data.fuelEstimatedLaps*100)
            else:
                connectedGame = RunningGame.NONE
        else:
            connectedGame = RunningGame.NONE
        r3reader.stop()

def main():
    global ffbReport
    global connectedGame
    oldConnectedGame = connectedGame
    check_plugin_config_change()
    check_ac_acc()
    check_iracing()
    check_rf2_lmu()
    check_raceroom()
    if oldConnectedGame != connectedGame:
        Log(str(connectedGame))
    if connectedGame == RunningGame.NONE:
        ffbReport.vnmFinalFFB = 0

def send_data():
    Report.Value['SendMode'] = 1
    Report.Value['RAW'] = ffbReport.to_bytes()

class PluginInfo:
   Name='Auto'
   PluginType='telemetry'
   Author='hoantv'
   Description='Plugin for many games'
   Version='1.1'